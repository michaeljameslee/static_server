webpackJsonp([2],{

/***/ 100:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// slide
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.Flickity = window.Flickity || {};
    window.Flickity.Slide = factory();
  }
})(window, function factory() {
  'use strict';

  function Slide(parent) {
    this.parent = parent;
    this.isOriginLeft = parent.originSide == 'left';
    this.cells = [];
    this.outerWidth = 0;
    this.height = 0;
  }

  var proto = Slide.prototype;

  proto.addCell = function (cell) {
    this.cells.push(cell);
    this.outerWidth += cell.size.outerWidth;
    this.height = Math.max(cell.size.outerHeight, this.height);
    // first cell stuff
    if (this.cells.length == 1) {
      this.x = cell.x; // x comes from first cell
      var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';
      this.firstMargin = cell.size[beginMargin];
    }
  };

  proto.updateTarget = function () {
    var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';
    var lastCell = this.getLastCell();
    var lastMargin = lastCell ? lastCell.size[endMargin] : 0;
    var slideWidth = this.outerWidth - (this.firstMargin + lastMargin);
    this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;
  };

  proto.getLastCell = function () {
    return this.cells[this.cells.length - 1];
  };

  proto.select = function () {
    this.changeSelectedClass('add');
  };

  proto.unselect = function () {
    this.changeSelectedClass('remove');
  };

  proto.changeSelectedClass = function (method) {
    this.cells.forEach(function (cell) {
      cell.element.classList[method]('is-selected');
    });
  };

  proto.getCellElements = function () {
    return this.cells.map(function (cell) {
      return cell.element;
    });
  };

  return Slide;
});

/***/ }),

/***/ 101:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// animate
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (utils) {
      return factory(window, utils);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('fizzy-ui-utils'));
  } else {
    // browser global
    window.Flickity = window.Flickity || {};
    window.Flickity.animatePrototype = factory(window, window.fizzyUIUtils);
  }
})(window, function factory(window, utils) {

  'use strict';

  // -------------------------- requestAnimationFrame -------------------------- //

  // get rAF, prefixed, if present

  var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;

  // fallback to setTimeout
  var lastTime = 0;
  if (!requestAnimationFrame) {
    requestAnimationFrame = function requestAnimationFrame(callback) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = setTimeout(callback, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }

  // -------------------------- animate -------------------------- //

  var proto = {};

  proto.startAnimation = function () {
    if (this.isAnimating) {
      return;
    }

    this.isAnimating = true;
    this.restingFrames = 0;
    this.animate();
  };

  proto.animate = function () {
    this.applyDragForce();
    this.applySelectedAttraction();

    var previousX = this.x;

    this.integratePhysics();
    this.positionSlider();
    this.settle(previousX);
    // animate next frame
    if (this.isAnimating) {
      var _this = this;
      requestAnimationFrame(function animateFrame() {
        _this.animate();
      });
    }
  };

  var transformProperty = function () {
    var style = document.documentElement.style;
    if (typeof style.transform == 'string') {
      return 'transform';
    }
    return 'WebkitTransform';
  }();

  proto.positionSlider = function () {
    var x = this.x;
    // wrap position around
    if (this.options.wrapAround && this.cells.length > 1) {
      x = utils.modulo(x, this.slideableWidth);
      x = x - this.slideableWidth;
      this.shiftWrapCells(x);
    }

    x = x + this.cursorPosition;
    // reverse if right-to-left and using transform
    x = this.options.rightToLeft && transformProperty ? -x : x;
    var value = this.getPositionValue(x);
    // use 3D tranforms for hardware acceleration on iOS
    // but use 2D when settled, for better font-rendering
    this.slider.style[transformProperty] = this.isAnimating ? 'translate3d(' + value + ',0,0)' : 'translateX(' + value + ')';

    // scroll event
    var firstSlide = this.slides[0];
    if (firstSlide) {
      var positionX = -this.x - firstSlide.target;
      var progress = positionX / this.slidesWidth;
      this.dispatchEvent('scroll', null, [progress, positionX]);
    }
  };

  proto.positionSliderAtSelected = function () {
    if (!this.cells.length) {
      return;
    }
    this.x = -this.selectedSlide.target;
    this.positionSlider();
  };

  proto.getPositionValue = function (position) {
    if (this.options.percentPosition) {
      // percent position, round to 2 digits, like 12.34%
      return Math.round(position / this.size.innerWidth * 10000) * 0.01 + '%';
    } else {
      // pixel positioning
      return Math.round(position) + 'px';
    }
  };

  proto.settle = function (previousX) {
    // keep track of frames where x hasn't moved
    if (!this.isPointerDown && Math.round(this.x * 100) == Math.round(previousX * 100)) {
      this.restingFrames++;
    }
    // stop animating if resting for 3 or more frames
    if (this.restingFrames > 2) {
      this.isAnimating = false;
      delete this.isFreeScrolling;
      // render position with translateX when settled
      this.positionSlider();
      this.dispatchEvent('settle');
    }
  };

  proto.shiftWrapCells = function (x) {
    // shift before cells
    var beforeGap = this.cursorPosition + x;
    this._shiftCells(this.beforeShiftCells, beforeGap, -1);
    // shift after cells
    var afterGap = this.size.innerWidth - (x + this.slideableWidth + this.cursorPosition);
    this._shiftCells(this.afterShiftCells, afterGap, 1);
  };

  proto._shiftCells = function (cells, gap, shift) {
    for (var i = 0; i < cells.length; i++) {
      var cell = cells[i];
      var cellShift = gap > 0 ? shift : 0;
      cell.wrapShift(cellShift);
      gap -= cell.size.outerWidth;
    }
  };

  proto._unshiftCells = function (cells) {
    if (!cells || !cells.length) {
      return;
    }
    for (var i = 0; i < cells.length; i++) {
      cells[i].wrapShift(0);
    }
  };

  // -------------------------- physics -------------------------- //

  proto.integratePhysics = function () {
    this.x += this.velocity;
    this.velocity *= this.getFrictionFactor();
  };

  proto.applyForce = function (force) {
    this.velocity += force;
  };

  proto.getFrictionFactor = function () {
    return 1 - this.options[this.isFreeScrolling ? 'freeScrollFriction' : 'friction'];
  };

  proto.getRestingPosition = function () {
    // my thanks to Steven Wittens, who simplified this math greatly
    return this.x + this.velocity / (1 - this.getFrictionFactor());
  };

  proto.applyDragForce = function () {
    if (!this.isPointerDown) {
      return;
    }
    // change the position to drag position by applying force
    var dragVelocity = this.dragX - this.x;
    var dragForce = dragVelocity - this.velocity;
    this.applyForce(dragForce);
  };

  proto.applySelectedAttraction = function () {
    // do not attract if pointer down or no cells
    if (this.isPointerDown || this.isFreeScrolling || !this.cells.length) {
      return;
    }
    var distance = this.selectedSlide.target * -1 - this.x;
    var force = distance * this.options.selectedAttraction;
    this.applyForce(force);
  };

  return proto;
});

/***/ }),

/***/ 102:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// drag
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(17), __webpack_require__(103), __webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Flickity, Unidragger, utils) {
      return factory(window, Flickity, Unidragger, utils);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('./flickity'), require('unidragger'), require('fizzy-ui-utils'));
  } else {
    // browser global
    window.Flickity = factory(window, window.Flickity, window.Unidragger, window.fizzyUIUtils);
  }
})(window, function factory(window, Flickity, Unidragger, utils) {

  'use strict';

  // ----- defaults ----- //

  utils.extend(Flickity.defaults, {
    draggable: true,
    dragThreshold: 3
  });

  // ----- create ----- //

  Flickity.createMethods.push('_createDrag');

  // -------------------------- drag prototype -------------------------- //

  var proto = Flickity.prototype;
  utils.extend(proto, Unidragger.prototype);
  proto._touchActionValue = 'pan-y';

  // --------------------------  -------------------------- //

  var isTouch = 'createTouch' in document;
  var isTouchmoveScrollCanceled = false;

  proto._createDrag = function () {
    this.on('activate', this.bindDrag);
    this.on('uiChange', this._uiChangeDrag);
    this.on('childUIPointerDown', this._childUIPointerDownDrag);
    this.on('deactivate', this.unbindDrag);
    // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior
    // #457, RubaXa/Sortable#973
    if (isTouch && !isTouchmoveScrollCanceled) {
      window.addEventListener('touchmove', function () {});
      isTouchmoveScrollCanceled = true;
    }
  };

  proto.bindDrag = function () {
    if (!this.options.draggable || this.isDragBound) {
      return;
    }
    this.element.classList.add('is-draggable');
    this.handles = [this.viewport];
    this.bindHandles();
    this.isDragBound = true;
  };

  proto.unbindDrag = function () {
    if (!this.isDragBound) {
      return;
    }
    this.element.classList.remove('is-draggable');
    this.unbindHandles();
    delete this.isDragBound;
  };

  proto._uiChangeDrag = function () {
    delete this.isFreeScrolling;
  };

  proto._childUIPointerDownDrag = function (event) {
    event.preventDefault();
    this.pointerDownFocus(event);
  };

  // -------------------------- pointer events -------------------------- //

  // nodes that have text fields
  var cursorNodes = {
    TEXTAREA: true,
    INPUT: true,
    OPTION: true
  };

  // input types that do not have text fields
  var clickTypes = {
    radio: true,
    checkbox: true,
    button: true,
    submit: true,
    image: true,
    file: true
  };

  proto.pointerDown = function (event, pointer) {
    // dismiss inputs with text fields. #403, #404
    var isCursorInput = cursorNodes[event.target.nodeName] && !clickTypes[event.target.type];
    if (isCursorInput) {
      // reset pointerDown logic
      this.isPointerDown = false;
      delete this.pointerIdentifier;
      return;
    }

    this._dragPointerDown(event, pointer);

    // kludge to blur focused inputs in dragger
    var focused = document.activeElement;
    if (focused && focused.blur && focused != this.element &&
    // do not blur body for IE9 & 10, #117
    focused != document.body) {
      focused.blur();
    }
    this.pointerDownFocus(event);
    // stop if it was moving
    this.dragX = this.x;
    this.viewport.classList.add('is-pointer-down');
    // bind move and end events
    this._bindPostStartEvents(event);
    // track scrolling
    this.pointerDownScroll = getScrollPosition();
    window.addEventListener('scroll', this);

    this.dispatchEvent('pointerDown', event, [pointer]);
  };

  proto.pointerDownFocus = function (event) {
    // focus element, if not touch, and its not an input or select
    var canPointerDown = getCanPointerDown(event);
    if (!this.options.accessibility || canPointerDown) {
      return;
    }
    var prevScrollY = window.pageYOffset;
    this.element.focus();
    // hack to fix scroll jump after focus, #76
    if (window.pageYOffset != prevScrollY) {
      window.scrollTo(window.pageXOffset, prevScrollY);
    }
  };

  var focusNodes = {
    INPUT: true,
    SELECT: true
  };

  function getCanPointerDown(event) {
    var isTouchStart = event.type == 'touchstart';
    var isTouchPointer = event.pointerType == 'touch';
    var isFocusNode = focusNodes[event.target.nodeName];
    return isTouchStart || isTouchPointer || isFocusNode;
  }

  proto.canPreventDefaultOnPointerDown = function (event) {
    // prevent default, unless touchstart or input
    var canPointerDown = getCanPointerDown(event);
    return !canPointerDown;
  };

  // ----- move ----- //

  proto.hasDragStarted = function (moveVector) {
    return Math.abs(moveVector.x) > this.options.dragThreshold;
  };

  // ----- up ----- //

  proto.pointerUp = function (event, pointer) {
    delete this.isTouchScrolling;
    this.viewport.classList.remove('is-pointer-down');
    this.dispatchEvent('pointerUp', event, [pointer]);
    this._dragPointerUp(event, pointer);
  };

  proto.pointerDone = function () {
    window.removeEventListener('scroll', this);
    delete this.pointerDownScroll;
  };

  // -------------------------- dragging -------------------------- //

  proto.dragStart = function (event, pointer) {
    this.dragStartPosition = this.x;
    this.startAnimation();
    window.removeEventListener('scroll', this);
    this.dispatchEvent('dragStart', event, [pointer]);
  };

  proto.pointerMove = function (event, pointer) {
    var moveVector = this._dragPointerMove(event, pointer);
    this.dispatchEvent('pointerMove', event, [pointer, moveVector]);
    this._dragMove(event, pointer, moveVector);
  };

  proto.dragMove = function (event, pointer, moveVector) {
    event.preventDefault();

    this.previousDragX = this.dragX;
    // reverse if right-to-left
    var direction = this.options.rightToLeft ? -1 : 1;
    var dragX = this.dragStartPosition + moveVector.x * direction;

    if (!this.options.wrapAround && this.slides.length) {
      // slow drag
      var originBound = Math.max(-this.slides[0].target, this.dragStartPosition);
      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;
      var endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);
      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;
    }

    this.dragX = dragX;

    this.dragMoveTime = new Date();
    this.dispatchEvent('dragMove', event, [pointer, moveVector]);
  };

  proto.dragEnd = function (event, pointer) {
    if (this.options.freeScroll) {
      this.isFreeScrolling = true;
    }
    // set selectedIndex based on where flick will end up
    var index = this.dragEndRestingSelect();

    if (this.options.freeScroll && !this.options.wrapAround) {
      // if free-scroll & not wrap around
      // do not free-scroll if going outside of bounding slides
      // so bounding slides can attract slider, and keep it in bounds
      var restingX = this.getRestingPosition();
      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;
    } else if (!this.options.freeScroll && index == this.selectedIndex) {
      // boost selection if selected index has not changed
      index += this.dragEndBoostSelect();
    }
    delete this.previousDragX;
    // apply selection
    // TODO refactor this, selecting here feels weird
    // HACK, set flag so dragging stays in correct direction
    this.isDragSelect = this.options.wrapAround;
    this.select(index);
    delete this.isDragSelect;
    this.dispatchEvent('dragEnd', event, [pointer]);
  };

  proto.dragEndRestingSelect = function () {
    var restingX = this.getRestingPosition();
    // how far away from selected slide
    var distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex));
    // get closet resting going up and going down
    var positiveResting = this._getClosestResting(restingX, distance, 1);
    var negativeResting = this._getClosestResting(restingX, distance, -1);
    // use closer resting for wrap-around
    var index = positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;
    return index;
  };

  /**
   * given resting X and distance to selected cell
   * get the distance and index of the closest cell
   * @param {Number} restingX - estimated post-flick resting position
   * @param {Number} distance - distance to selected cell
   * @param {Integer} increment - +1 or -1, going up or down
   * @returns {Object} - { distance: {Number}, index: {Integer} }
   */
  proto._getClosestResting = function (restingX, distance, increment) {
    var index = this.selectedIndex;
    var minDistance = Infinity;
    var condition = this.options.contain && !this.options.wrapAround ?
    // if contain, keep going if distance is equal to minDistance
    function (d, md) {
      return d <= md;
    } : function (d, md) {
      return d < md;
    };
    while (condition(distance, minDistance)) {
      // measure distance to next cell
      index += increment;
      minDistance = distance;
      distance = this.getSlideDistance(-restingX, index);
      if (distance === null) {
        break;
      }
      distance = Math.abs(distance);
    }
    return {
      distance: minDistance,
      // selected was previous index
      index: index - increment
    };
  };

  /**
   * measure distance between x and a slide target
   * @param {Number} x
   * @param {Integer} index - slide index
   */
  proto.getSlideDistance = function (x, index) {
    var len = this.slides.length;
    // wrap around if at least 2 slides
    var isWrapAround = this.options.wrapAround && len > 1;
    var slideIndex = isWrapAround ? utils.modulo(index, len) : index;
    var slide = this.slides[slideIndex];
    if (!slide) {
      return null;
    }
    // add distance for wrap-around slides
    var wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;
    return x - (slide.target + wrap);
  };

  proto.dragEndBoostSelect = function () {
    // do not boost if no previousDragX or dragMoveTime
    if (this.previousDragX === undefined || !this.dragMoveTime ||
    // or if drag was held for 100 ms
    new Date() - this.dragMoveTime > 100) {
      return 0;
    }

    var distance = this.getSlideDistance(-this.dragX, this.selectedIndex);
    var delta = this.previousDragX - this.dragX;
    if (distance > 0 && delta > 0) {
      // boost to next if moving towards the right, and positive velocity
      return 1;
    } else if (distance < 0 && delta < 0) {
      // boost to previous if moving towards the left, and negative velocity
      return -1;
    }
    return 0;
  };

  // ----- staticClick ----- //

  proto.staticClick = function (event, pointer) {
    // get clickedCell, if cell was clicked
    var clickedCell = this.getParentCell(event.target);
    var cellElem = clickedCell && clickedCell.element;
    var cellIndex = clickedCell && this.cells.indexOf(clickedCell);
    this.dispatchEvent('staticClick', event, [pointer, cellElem, cellIndex]);
  };

  // ----- scroll ----- //

  proto.onscroll = function () {
    var scroll = getScrollPosition();
    var scrollMoveX = this.pointerDownScroll.x - scroll.x;
    var scrollMoveY = this.pointerDownScroll.y - scroll.y;
    // cancel click/tap if scroll is too much
    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {
      this._pointerDone();
    }
  };

  // ----- utils ----- //

  function getScrollPosition() {
    return {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }

  // -----  ----- //

  return Flickity;
});

/***/ }),

/***/ 103:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Unidragger v2.2.3
 * Draggable base class
 * MIT license
 */

/*jshint browser: true, unused: true, undef: true, strict: true */

(function (window, factory) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */

  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(69)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Unipointer) {
      return factory(window, Unipointer);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('unipointer'));
  } else {
    // browser global
    window.Unidragger = factory(window, window.Unipointer);
  }
})(window, function factory(window, Unipointer) {

  'use strict';

  // -------------------------- Unidragger -------------------------- //

  function Unidragger() {}

  // inherit Unipointer & EvEmitter
  var proto = Unidragger.prototype = Object.create(Unipointer.prototype);

  // ----- bind start ----- //

  proto.bindHandles = function () {
    this._bindHandles(true);
  };

  proto.unbindHandles = function () {
    this._bindHandles(false);
  };

  /**
   * works as unbinder, as you can .bindHandles( false ) to unbind
   * @param {Boolean} isBind - will unbind if falsey
   */
  proto._bindHandles = function (isBind) {
    // munge isBind, default to true
    isBind = isBind === undefined ? true : !!isBind;
    // bind each handle
    var bindMethod = isBind ? 'addEventListener' : 'removeEventListener';
    for (var i = 0; i < this.handles.length; i++) {
      var handle = this.handles[i];
      this._bindStartEvent(handle, isBind);
      handle[bindMethod]('click', this);
      // touch-action: none to override browser touch gestures
      // metafizzy/flickity#540
      if (window.PointerEvent) {
        handle.style.touchAction = isBind ? this._touchActionValue : '';
      }
    }
  };

  // prototype so it can be overwriteable by Flickity
  proto._touchActionValue = 'none';

  // ----- start event ----- //

  /**
   * pointer start
   * @param {Event} event
   * @param {Event or Touch} pointer
   */
  proto.pointerDown = function (event, pointer) {
    // dismiss range sliders
    if (event.target.nodeName == 'INPUT' && event.target.type == 'range') {
      // reset pointerDown logic
      this.isPointerDown = false;
      delete this.pointerIdentifier;
      return;
    }

    this._dragPointerDown(event, pointer);
    // kludge to blur focused inputs in dragger
    var focused = document.activeElement;
    if (focused && focused.blur) {
      focused.blur();
    }
    // bind move and end events
    this._bindPostStartEvents(event);
    this.emitEvent('pointerDown', [event, pointer]);
  };

  // base pointer down logic
  proto._dragPointerDown = function (event, pointer) {
    // track to see when dragging starts
    this.pointerDownPoint = Unipointer.getPointerPoint(pointer);

    var canPreventDefault = this.canPreventDefaultOnPointerDown(event, pointer);
    if (canPreventDefault) {
      event.preventDefault();
    }
  };

  // overwriteable method so Flickity can prevent for scrolling
  proto.canPreventDefaultOnPointerDown = function (event) {
    // prevent default, unless touchstart or <select>
    return event.target.nodeName != 'SELECT';
  };

  // ----- move event ----- //

  /**
   * drag move
   * @param {Event} event
   * @param {Event or Touch} pointer
   */
  proto.pointerMove = function (event, pointer) {
    var moveVector = this._dragPointerMove(event, pointer);
    this.emitEvent('pointerMove', [event, pointer, moveVector]);
    this._dragMove(event, pointer, moveVector);
  };

  // base pointer move logic
  proto._dragPointerMove = function (event, pointer) {
    var movePoint = Unipointer.getPointerPoint(pointer);
    var moveVector = {
      x: movePoint.x - this.pointerDownPoint.x,
      y: movePoint.y - this.pointerDownPoint.y
    };
    // start drag if pointer has moved far enough to start drag
    if (!this.isDragging && this.hasDragStarted(moveVector)) {
      this._dragStart(event, pointer);
    }
    return moveVector;
  };

  // condition if pointer has moved far enough to start drag
  proto.hasDragStarted = function (moveVector) {
    return Math.abs(moveVector.x) > 3 || Math.abs(moveVector.y) > 3;
  };

  // ----- end event ----- //

  /**
   * pointer up
   * @param {Event} event
   * @param {Event or Touch} pointer
   */
  proto.pointerUp = function (event, pointer) {
    this.emitEvent('pointerUp', [event, pointer]);
    this._dragPointerUp(event, pointer);
  };

  proto._dragPointerUp = function (event, pointer) {
    if (this.isDragging) {
      this._dragEnd(event, pointer);
    } else {
      // pointer didn't move enough for drag to start
      this._staticClick(event, pointer);
    }
  };

  // -------------------------- drag -------------------------- //

  // dragStart
  proto._dragStart = function (event, pointer) {
    this.isDragging = true;
    this.dragStartPoint = Unipointer.getPointerPoint(pointer);
    // prevent clicks
    this.isPreventingClicks = true;

    this.dragStart(event, pointer);
  };

  proto.dragStart = function (event, pointer) {
    this.emitEvent('dragStart', [event, pointer]);
  };

  // dragMove
  proto._dragMove = function (event, pointer, moveVector) {
    // do not drag if not dragging yet
    if (!this.isDragging) {
      return;
    }

    this.dragMove(event, pointer, moveVector);
  };

  proto.dragMove = function (event, pointer, moveVector) {
    event.preventDefault();
    this.emitEvent('dragMove', [event, pointer, moveVector]);
  };

  // dragEnd
  proto._dragEnd = function (event, pointer) {
    // set flags
    this.isDragging = false;
    // re-enable clicking async
    setTimeout(function () {
      delete this.isPreventingClicks;
    }.bind(this));

    this.dragEnd(event, pointer);
  };

  proto.dragEnd = function (event, pointer) {
    this.emitEvent('dragEnd', [event, pointer]);
  };

  // ----- onclick ----- //

  // handle all clicks and prevent clicks when dragging
  proto.onclick = function (event) {
    if (this.isPreventingClicks) {
      event.preventDefault();
    }
  };

  // ----- staticClick ----- //

  // triggered after pointer down & up with no/tiny movement
  proto._staticClick = function (event, pointer) {
    // ignore emulated mouse up clicks
    if (this.isIgnoringMouseUp && event.type == 'mouseup') {
      return;
    }

    // allow click in <input>s and <textarea>s
    var nodeName = event.target.nodeName;
    if (nodeName == 'INPUT' || nodeName == 'TEXTAREA') {
      event.target.focus();
    }
    this.staticClick(event, pointer);

    // set flag for emulated clicks 300ms after touchend
    if (event.type != 'mouseup') {
      this.isIgnoringMouseUp = true;
      // reset flag after 300ms
      setTimeout(function () {
        delete this.isIgnoringMouseUp;
      }.bind(this), 400);
    }
  };

  proto.staticClick = function (event, pointer) {
    this.emitEvent('staticClick', [event, pointer]);
  };

  // ----- utils ----- //

  Unidragger.getPointerPoint = Unipointer.getPointerPoint;

  // -----  ----- //

  return Unidragger;
});

/***/ }),

/***/ 104:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// prev/next buttons
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(17), __webpack_require__(70), __webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Flickity, TapListener, utils) {
      return factory(window, Flickity, TapListener, utils);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('./flickity'), require('tap-listener'), require('fizzy-ui-utils'));
  } else {
    // browser global
    factory(window, window.Flickity, window.TapListener, window.fizzyUIUtils);
  }
})(window, function factory(window, Flickity, TapListener, utils) {
  'use strict';

  var svgURI = 'http://www.w3.org/2000/svg';

  // -------------------------- PrevNextButton -------------------------- //

  function PrevNextButton(direction, parent) {
    this.direction = direction;
    this.parent = parent;
    this._create();
  }

  PrevNextButton.prototype = new TapListener();

  PrevNextButton.prototype._create = function () {
    // properties
    this.isEnabled = true;
    this.isPrevious = this.direction == -1;
    var leftDirection = this.parent.options.rightToLeft ? 1 : -1;
    this.isLeft = this.direction == leftDirection;

    var element = this.element = document.createElement('button');
    element.className = 'flickity-prev-next-button';
    element.className += this.isPrevious ? ' previous' : ' next';
    // prevent button from submitting form http://stackoverflow.com/a/10836076/182183
    element.setAttribute('type', 'button');
    // init as disabled
    this.disable();

    element.setAttribute('aria-label', this.isPrevious ? 'previous' : 'next');

    // create arrow
    var svg = this.createSVG();
    element.appendChild(svg);
    // events
    this.on('tap', this.onTap);
    this.parent.on('select', this.update.bind(this));
    this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));
  };

  PrevNextButton.prototype.activate = function () {
    this.bindTap(this.element);
    // click events from keyboard
    this.element.addEventListener('click', this);
    // add to DOM
    this.parent.element.appendChild(this.element);
  };

  PrevNextButton.prototype.deactivate = function () {
    // remove from DOM
    this.parent.element.removeChild(this.element);
    // do regular TapListener destroy
    TapListener.prototype.destroy.call(this);
    // click events from keyboard
    this.element.removeEventListener('click', this);
  };

  PrevNextButton.prototype.createSVG = function () {
    var svg = document.createElementNS(svgURI, 'svg');
    svg.setAttribute('viewBox', '0 0 100 100');
    var path = document.createElementNS(svgURI, 'path');
    var pathMovements = getArrowMovements(this.parent.options.arrowShape);
    path.setAttribute('d', pathMovements);
    path.setAttribute('class', 'arrow');
    // rotate arrow
    if (!this.isLeft) {
      path.setAttribute('transform', 'translate(100, 100) rotate(180) ');
    }
    svg.appendChild(path);
    return svg;
  };

  // get SVG path movmement
  function getArrowMovements(shape) {
    // use shape as movement if string
    if (typeof shape == 'string') {
      return shape;
    }
    // create movement string
    return 'M ' + shape.x0 + ',50' + ' L ' + shape.x1 + ',' + (shape.y1 + 50) + ' L ' + shape.x2 + ',' + (shape.y2 + 50) + ' L ' + shape.x3 + ',50 ' + ' L ' + shape.x2 + ',' + (50 - shape.y2) + ' L ' + shape.x1 + ',' + (50 - shape.y1) + ' Z';
  }

  PrevNextButton.prototype.onTap = function () {
    if (!this.isEnabled) {
      return;
    }
    this.parent.uiChange();
    var method = this.isPrevious ? 'previous' : 'next';
    this.parent[method]();
  };

  PrevNextButton.prototype.handleEvent = utils.handleEvent;

  PrevNextButton.prototype.onclick = function () {
    // only allow clicks from keyboard
    var focused = document.activeElement;
    if (focused && focused == this.element) {
      this.onTap();
    }
  };

  // -----  ----- //

  PrevNextButton.prototype.enable = function () {
    if (this.isEnabled) {
      return;
    }
    this.element.disabled = false;
    this.isEnabled = true;
  };

  PrevNextButton.prototype.disable = function () {
    if (!this.isEnabled) {
      return;
    }
    this.element.disabled = true;
    this.isEnabled = false;
  };

  PrevNextButton.prototype.update = function () {
    // index of first or last slide, if previous or next
    var slides = this.parent.slides;
    // enable is wrapAround and at least 2 slides
    if (this.parent.options.wrapAround && slides.length > 1) {
      this.enable();
      return;
    }
    var lastIndex = slides.length ? slides.length - 1 : 0;
    var boundIndex = this.isPrevious ? 0 : lastIndex;
    var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';
    this[method]();
  };

  PrevNextButton.prototype.destroy = function () {
    this.deactivate();
  };

  // -------------------------- Flickity prototype -------------------------- //

  utils.extend(Flickity.defaults, {
    prevNextButtons: true,
    arrowShape: {
      x0: 10,
      x1: 60, y1: 50,
      x2: 70, y2: 40,
      x3: 30
    }
  });

  Flickity.createMethods.push('_createPrevNextButtons');
  var proto = Flickity.prototype;

  proto._createPrevNextButtons = function () {
    if (!this.options.prevNextButtons) {
      return;
    }

    this.prevButton = new PrevNextButton(-1, this);
    this.nextButton = new PrevNextButton(1, this);

    this.on('activate', this.activatePrevNextButtons);
  };

  proto.activatePrevNextButtons = function () {
    this.prevButton.activate();
    this.nextButton.activate();
    this.on('deactivate', this.deactivatePrevNextButtons);
  };

  proto.deactivatePrevNextButtons = function () {
    this.prevButton.deactivate();
    this.nextButton.deactivate();
    this.off('deactivate', this.deactivatePrevNextButtons);
  };

  // --------------------------  -------------------------- //

  Flickity.PrevNextButton = PrevNextButton;

  return Flickity;
});

/***/ }),

/***/ 105:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// page dots
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(17), __webpack_require__(70), __webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Flickity, TapListener, utils) {
      return factory(window, Flickity, TapListener, utils);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('./flickity'), require('tap-listener'), require('fizzy-ui-utils'));
  } else {
    // browser global
    factory(window, window.Flickity, window.TapListener, window.fizzyUIUtils);
  }
})(window, function factory(window, Flickity, TapListener, utils) {

  // -------------------------- PageDots -------------------------- //

  'use strict';

  function PageDots(parent) {
    this.parent = parent;
    this._create();
  }

  PageDots.prototype = new TapListener();

  PageDots.prototype._create = function () {
    // create holder element
    this.holder = document.createElement('ol');
    this.holder.className = 'flickity-page-dots';
    // create dots, array of elements
    this.dots = [];
    // events
    this.on('tap', this.onTap);
    this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));
  };

  PageDots.prototype.activate = function () {
    this.setDots();
    this.bindTap(this.holder);
    // add to DOM
    this.parent.element.appendChild(this.holder);
  };

  PageDots.prototype.deactivate = function () {
    // remove from DOM
    this.parent.element.removeChild(this.holder);
    TapListener.prototype.destroy.call(this);
  };

  PageDots.prototype.setDots = function () {
    // get difference between number of slides and number of dots
    var delta = this.parent.slides.length - this.dots.length;
    if (delta > 0) {
      this.addDots(delta);
    } else if (delta < 0) {
      this.removeDots(-delta);
    }
  };

  PageDots.prototype.addDots = function (count) {
    var fragment = document.createDocumentFragment();
    var newDots = [];
    while (count) {
      var dot = document.createElement('li');
      dot.className = 'dot';
      fragment.appendChild(dot);
      newDots.push(dot);
      count--;
    }
    this.holder.appendChild(fragment);
    this.dots = this.dots.concat(newDots);
  };

  PageDots.prototype.removeDots = function (count) {
    // remove from this.dots collection
    var removeDots = this.dots.splice(this.dots.length - count, count);
    // remove from DOM
    removeDots.forEach(function (dot) {
      this.holder.removeChild(dot);
    }, this);
  };

  PageDots.prototype.updateSelected = function () {
    // remove selected class on previous
    if (this.selectedDot) {
      this.selectedDot.className = 'dot';
    }
    // don't proceed if no dots
    if (!this.dots.length) {
      return;
    }
    this.selectedDot = this.dots[this.parent.selectedIndex];
    this.selectedDot.className = 'dot is-selected';
  };

  PageDots.prototype.onTap = function (event) {
    var target = event.target;
    // only care about dot clicks
    if (target.nodeName != 'LI') {
      return;
    }

    this.parent.uiChange();
    var index = this.dots.indexOf(target);
    this.parent.select(index);
  };

  PageDots.prototype.destroy = function () {
    this.deactivate();
  };

  Flickity.PageDots = PageDots;

  // -------------------------- Flickity -------------------------- //

  utils.extend(Flickity.defaults, {
    pageDots: true
  });

  Flickity.createMethods.push('_createPageDots');

  var proto = Flickity.prototype;

  proto._createPageDots = function () {
    if (!this.options.pageDots) {
      return;
    }
    this.pageDots = new PageDots(this);
    // events
    this.on('activate', this.activatePageDots);
    this.on('select', this.updateSelectedPageDots);
    this.on('cellChange', this.updatePageDots);
    this.on('resize', this.updatePageDots);
    this.on('deactivate', this.deactivatePageDots);
  };

  proto.activatePageDots = function () {
    this.pageDots.activate();
  };

  proto.updateSelectedPageDots = function () {
    this.pageDots.updateSelected();
  };

  proto.updatePageDots = function () {
    this.pageDots.setDots();
  };

  proto.deactivatePageDots = function () {
    this.pageDots.deactivate();
  };

  // -----  ----- //

  Flickity.PageDots = PageDots;

  return Flickity;
});

/***/ }),

/***/ 106:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// player & autoPlay
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(48), __webpack_require__(16), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function (EvEmitter, utils, Flickity) {
      return factory(EvEmitter, utils, Flickity);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(require('ev-emitter'), require('fizzy-ui-utils'), require('./flickity'));
  } else {
    // browser global
    factory(window.EvEmitter, window.fizzyUIUtils, window.Flickity);
  }
})(window, function factory(EvEmitter, utils, Flickity) {

  'use strict';

  // -------------------------- Page Visibility -------------------------- //
  // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API

  var hiddenProperty, visibilityEvent;
  if ('hidden' in document) {
    hiddenProperty = 'hidden';
    visibilityEvent = 'visibilitychange';
  } else if ('webkitHidden' in document) {
    hiddenProperty = 'webkitHidden';
    visibilityEvent = 'webkitvisibilitychange';
  }

  // -------------------------- Player -------------------------- //

  function Player(parent) {
    this.parent = parent;
    this.state = 'stopped';
    // visibility change event handler
    if (visibilityEvent) {
      this.onVisibilityChange = function () {
        this.visibilityChange();
      }.bind(this);
      this.onVisibilityPlay = function () {
        this.visibilityPlay();
      }.bind(this);
    }
  }

  Player.prototype = Object.create(EvEmitter.prototype);

  // start play
  Player.prototype.play = function () {
    if (this.state == 'playing') {
      return;
    }
    // do not play if page is hidden, start playing when page is visible
    var isPageHidden = document[hiddenProperty];
    if (visibilityEvent && isPageHidden) {
      document.addEventListener(visibilityEvent, this.onVisibilityPlay);
      return;
    }

    this.state = 'playing';
    // listen to visibility change
    if (visibilityEvent) {
      document.addEventListener(visibilityEvent, this.onVisibilityChange);
    }
    // start ticking
    this.tick();
  };

  Player.prototype.tick = function () {
    // do not tick if not playing
    if (this.state != 'playing') {
      return;
    }

    var time = this.parent.options.autoPlay;
    // default to 3 seconds
    time = typeof time == 'number' ? time : 3000;
    var _this = this;
    // HACK: reset ticks if stopped and started within interval
    this.clear();
    this.timeout = setTimeout(function () {
      _this.parent.next(true);
      _this.tick();
    }, time);
  };

  Player.prototype.stop = function () {
    this.state = 'stopped';
    this.clear();
    // remove visibility change event
    if (visibilityEvent) {
      document.removeEventListener(visibilityEvent, this.onVisibilityChange);
    }
  };

  Player.prototype.clear = function () {
    clearTimeout(this.timeout);
  };

  Player.prototype.pause = function () {
    if (this.state == 'playing') {
      this.state = 'paused';
      this.clear();
    }
  };

  Player.prototype.unpause = function () {
    // re-start play if paused
    if (this.state == 'paused') {
      this.play();
    }
  };

  // pause if page visibility is hidden, unpause if visible
  Player.prototype.visibilityChange = function () {
    var isPageHidden = document[hiddenProperty];
    this[isPageHidden ? 'pause' : 'unpause']();
  };

  Player.prototype.visibilityPlay = function () {
    this.play();
    document.removeEventListener(visibilityEvent, this.onVisibilityPlay);
  };

  // -------------------------- Flickity -------------------------- //

  utils.extend(Flickity.defaults, {
    pauseAutoPlayOnHover: true
  });

  Flickity.createMethods.push('_createPlayer');
  var proto = Flickity.prototype;

  proto._createPlayer = function () {
    this.player = new Player(this);

    this.on('activate', this.activatePlayer);
    this.on('uiChange', this.stopPlayer);
    this.on('pointerDown', this.stopPlayer);
    this.on('deactivate', this.deactivatePlayer);
  };

  proto.activatePlayer = function () {
    if (!this.options.autoPlay) {
      return;
    }
    this.player.play();
    this.element.addEventListener('mouseenter', this);
  };

  // Player API, don't hate the ... thanks I know where the door is

  proto.playPlayer = function () {
    this.player.play();
  };

  proto.stopPlayer = function () {
    this.player.stop();
  };

  proto.pausePlayer = function () {
    this.player.pause();
  };

  proto.unpausePlayer = function () {
    this.player.unpause();
  };

  proto.deactivatePlayer = function () {
    this.player.stop();
    this.element.removeEventListener('mouseenter', this);
  };

  // ----- mouseenter/leave ----- //

  // pause auto-play on hover
  proto.onmouseenter = function () {
    if (!this.options.pauseAutoPlayOnHover) {
      return;
    }
    this.player.pause();
    this.element.addEventListener('mouseleave', this);
  };

  // resume auto-play on hover off
  proto.onmouseleave = function () {
    this.player.unpause();
    this.element.removeEventListener('mouseleave', this);
  };

  // -----  ----- //

  Flickity.Player = Player;

  return Flickity;
});

/***/ }),

/***/ 107:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// add, remove cell
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(17), __webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Flickity, utils) {
      return factory(window, Flickity, utils);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('./flickity'), require('fizzy-ui-utils'));
  } else {
    // browser global
    factory(window, window.Flickity, window.fizzyUIUtils);
  }
})(window, function factory(window, Flickity, utils) {

  'use strict';

  // append cells to a document fragment

  function getCellsFragment(cells) {
    var fragment = document.createDocumentFragment();
    cells.forEach(function (cell) {
      fragment.appendChild(cell.element);
    });
    return fragment;
  }

  // -------------------------- add/remove cell prototype -------------------------- //

  var proto = Flickity.prototype;

  /**
   * Insert, prepend, or append cells
   * @param {Element, Array, NodeList} elems
   * @param {Integer} index
   */
  proto.insert = function (elems, index) {
    var cells = this._makeCells(elems);
    if (!cells || !cells.length) {
      return;
    }
    var len = this.cells.length;
    // default to append
    index = index === undefined ? len : index;
    // add cells with document fragment
    var fragment = getCellsFragment(cells);
    // append to slider
    var isAppend = index == len;
    if (isAppend) {
      this.slider.appendChild(fragment);
    } else {
      var insertCellElement = this.cells[index].element;
      this.slider.insertBefore(fragment, insertCellElement);
    }
    // add to this.cells
    if (index === 0) {
      // prepend, add to start
      this.cells = cells.concat(this.cells);
    } else if (isAppend) {
      // append, add to end
      this.cells = this.cells.concat(cells);
    } else {
      // insert in this.cells
      var endCells = this.cells.splice(index, len - index);
      this.cells = this.cells.concat(cells).concat(endCells);
    }

    this._sizeCells(cells);

    var selectedIndexDelta = index > this.selectedIndex ? 0 : cells.length;
    this._cellAddedRemoved(index, selectedIndexDelta);
  };

  proto.append = function (elems) {
    this.insert(elems, this.cells.length);
  };

  proto.prepend = function (elems) {
    this.insert(elems, 0);
  };

  /**
   * Remove cells
   * @param {Element, Array, NodeList} elems
   */
  proto.remove = function (elems) {
    var cells = this.getCells(elems);
    var selectedIndexDelta = 0;
    var len = cells.length;
    var i, cell;
    // calculate selectedIndexDelta, easier if done in seperate loop
    for (i = 0; i < len; i++) {
      cell = cells[i];
      var wasBefore = this.cells.indexOf(cell) < this.selectedIndex;
      selectedIndexDelta -= wasBefore ? 1 : 0;
    }

    for (i = 0; i < len; i++) {
      cell = cells[i];
      cell.remove();
      // remove item from collection
      utils.removeFrom(this.cells, cell);
    }

    if (cells.length) {
      // update stuff
      this._cellAddedRemoved(0, selectedIndexDelta);
    }
  };

  // updates when cells are added or removed
  proto._cellAddedRemoved = function (changedCellIndex, selectedIndexDelta) {
    // TODO this math isn't perfect with grouped slides
    selectedIndexDelta = selectedIndexDelta || 0;
    this.selectedIndex += selectedIndexDelta;
    this.selectedIndex = Math.max(0, Math.min(this.slides.length - 1, this.selectedIndex));

    this.cellChange(changedCellIndex, true);
    // backwards compatibility
    this.emitEvent('cellAddedRemoved', [changedCellIndex, selectedIndexDelta]);
  };

  /**
   * logic to be run after a cell's size changes
   * @param {Element} elem - cell's element
   */
  proto.cellSizeChange = function (elem) {
    var cell = this.getCell(elem);
    if (!cell) {
      return;
    }
    cell.getSize();

    var index = this.cells.indexOf(cell);
    this.cellChange(index);
  };

  /**
   * logic any time a cell is changed: added, removed, or size changed
   * @param {Integer} changedCellIndex - index of the changed cell, optional
   */
  proto.cellChange = function (changedCellIndex, isPositioningSlider) {
    var prevSlideableWidth = this.slideableWidth;
    this._positionCells(changedCellIndex);
    this._getWrapShiftCells();
    this.setGallerySize();
    this.emitEvent('cellChange', [changedCellIndex]);
    // position slider
    if (this.options.freeScroll) {
      // shift x by change in slideableWidth
      // TODO fix position shifts when prepending w/ freeScroll
      var deltaX = prevSlideableWidth - this.slideableWidth;
      this.x += deltaX * this.cellAlign;
      this.positionSlider();
    } else {
      // do not position slider after lazy load
      if (isPositioningSlider) {
        this.positionSliderAtSelected();
      }
      this.select(this.selectedIndex);
    }
  };

  // -----  ----- //

  return Flickity;
});

/***/ }),

/***/ 108:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// lazyload
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(17), __webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Flickity, utils) {
      return factory(window, Flickity, utils);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('./flickity'), require('fizzy-ui-utils'));
  } else {
    // browser global
    factory(window, window.Flickity, window.fizzyUIUtils);
  }
})(window, function factory(window, Flickity, utils) {
  'use strict';

  Flickity.createMethods.push('_createLazyload');
  var proto = Flickity.prototype;

  proto._createLazyload = function () {
    this.on('select', this.lazyLoad);
  };

  proto.lazyLoad = function () {
    var lazyLoad = this.options.lazyLoad;
    if (!lazyLoad) {
      return;
    }
    // get adjacent cells, use lazyLoad option for adjacent count
    var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;
    var cellElems = this.getAdjacentCellElements(adjCount);
    // get lazy images in those cells
    var lazyImages = [];
    cellElems.forEach(function (cellElem) {
      var lazyCellImages = getCellLazyImages(cellElem);
      lazyImages = lazyImages.concat(lazyCellImages);
    });
    // load lazy images
    lazyImages.forEach(function (img) {
      new LazyLoader(img, this);
    }, this);
  };

  function getCellLazyImages(cellElem) {
    // check if cell element is lazy image
    if (cellElem.nodeName == 'IMG' && cellElem.getAttribute('data-flickity-lazyload')) {
      return [cellElem];
    }
    // select lazy images in cell
    var imgs = cellElem.querySelectorAll('img[data-flickity-lazyload]');
    return utils.makeArray(imgs);
  }

  // -------------------------- LazyLoader -------------------------- //

  /**
   * class to handle loading images
   */
  function LazyLoader(img, flickity) {
    this.img = img;
    this.flickity = flickity;
    this.load();
  }

  LazyLoader.prototype.handleEvent = utils.handleEvent;

  LazyLoader.prototype.load = function () {
    this.img.addEventListener('load', this);
    this.img.addEventListener('error', this);
    // load image
    this.img.src = this.img.getAttribute('data-flickity-lazyload');
    // remove attr
    this.img.removeAttribute('data-flickity-lazyload');
  };

  LazyLoader.prototype.onload = function (event) {
    this.complete(event, 'flickity-lazyloaded');
  };

  LazyLoader.prototype.onerror = function (event) {
    this.complete(event, 'flickity-lazyerror');
  };

  LazyLoader.prototype.complete = function (event, className) {
    // unbind events
    this.img.removeEventListener('load', this);
    this.img.removeEventListener('error', this);

    var cell = this.flickity.getParentCell(this.img);
    var cellElem = cell && cell.element;
    this.flickity.cellSizeChange(cellElem);

    this.img.classList.add(className);
    this.flickity.dispatchEvent('lazyLoad', event, cellElem);
  };

  // -----  ----- //

  Flickity.LazyLoader = LazyLoader;

  return Flickity;
});

/***/ }),

/***/ 16:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Fizzy UI utils v2.0.5
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

(function (window, factory) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */

  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(98)], __WEBPACK_AMD_DEFINE_RESULT__ = function (matchesSelector) {
      return factory(window, matchesSelector);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('desandro-matches-selector'));
  } else {
    // browser global
    window.fizzyUIUtils = factory(window, window.matchesSelector);
  }
})(window, function factory(window, matchesSelector) {

  'use strict';

  var utils = {};

  // ----- extend ----- //

  // extends objects
  utils.extend = function (a, b) {
    for (var prop in b) {
      a[prop] = b[prop];
    }
    return a;
  };

  // ----- modulo ----- //

  utils.modulo = function (num, div) {
    return (num % div + div) % div;
  };

  // ----- makeArray ----- //

  // turn element or nodeList into an array
  utils.makeArray = function (obj) {
    var ary = [];
    if (Array.isArray(obj)) {
      // use object if already an array
      ary = obj;
    } else if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' && typeof obj.length == 'number') {
      // convert nodeList to array
      for (var i = 0; i < obj.length; i++) {
        ary.push(obj[i]);
      }
    } else {
      // array of single index
      ary.push(obj);
    }
    return ary;
  };

  // ----- removeFrom ----- //

  utils.removeFrom = function (ary, obj) {
    var index = ary.indexOf(obj);
    if (index != -1) {
      ary.splice(index, 1);
    }
  };

  // ----- getParent ----- //

  utils.getParent = function (elem, selector) {
    while (elem.parentNode && elem != document.body) {
      elem = elem.parentNode;
      if (matchesSelector(elem, selector)) {
        return elem;
      }
    }
  };

  // ----- getQueryElement ----- //

  // use element as selector string
  utils.getQueryElement = function (elem) {
    if (typeof elem == 'string') {
      return document.querySelector(elem);
    }
    return elem;
  };

  // ----- handleEvent ----- //

  // enable .ontype to trigger from .addEventListener( elem, 'type' )
  utils.handleEvent = function (event) {
    var method = 'on' + event.type;
    if (this[method]) {
      this[method](event);
    }
  };

  // ----- filterFindElements ----- //

  utils.filterFindElements = function (elems, selector) {
    // make array of elems
    elems = utils.makeArray(elems);
    var ffElems = [];

    elems.forEach(function (elem) {
      // check that elem is an actual element
      if (!(elem instanceof HTMLElement)) {
        return;
      }
      // add elem if no selector
      if (!selector) {
        ffElems.push(elem);
        return;
      }
      // filter & find items if we have a selector
      // filter
      if (matchesSelector(elem, selector)) {
        ffElems.push(elem);
      }
      // find children
      var childElems = elem.querySelectorAll(selector);
      // concat childElems to filterFound array
      for (var i = 0; i < childElems.length; i++) {
        ffElems.push(childElems[i]);
      }
    });

    return ffElems;
  };

  // ----- debounceMethod ----- //

  utils.debounceMethod = function (_class, methodName, threshold) {
    // original method
    var method = _class.prototype[methodName];
    var timeoutName = methodName + 'Timeout';

    _class.prototype[methodName] = function () {
      var timeout = this[timeoutName];
      if (timeout) {
        clearTimeout(timeout);
      }
      var args = arguments;

      var _this = this;
      this[timeoutName] = setTimeout(function () {
        method.apply(_this, args);
        delete _this[timeoutName];
      }, threshold || 100);
    };
  };

  // ----- docReady ----- //

  utils.docReady = function (callback) {
    var readyState = document.readyState;
    if (readyState == 'complete' || readyState == 'interactive') {
      // do async to allow for other scripts to run. metafizzy/flickity#441
      setTimeout(callback);
    } else {
      document.addEventListener('DOMContentLoaded', callback);
    }
  };

  // ----- htmlInit ----- //

  // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
  utils.toDashed = function (str) {
    return str.replace(/(.)([A-Z])/g, function (match, $1, $2) {
      return $1 + '-' + $2;
    }).toLowerCase();
  };

  var console = window.console;
  /**
   * allow user to initialize classes via [data-namespace] or .js-namespace class
   * htmlInit( Widget, 'widgetName' )
   * options are parsed from data-namespace-options
   */
  utils.htmlInit = function (WidgetClass, namespace) {
    utils.docReady(function () {
      var dashedNamespace = utils.toDashed(namespace);
      var dataAttr = 'data-' + dashedNamespace;
      var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');
      var jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);
      var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));
      var dataOptionsAttr = dataAttr + '-options';
      var jQuery = window.jQuery;

      elems.forEach(function (elem) {
        var attr = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);
        var options;
        try {
          options = attr && JSON.parse(attr);
        } catch (error) {
          // log error, do not initialize
          if (console) {
            console.error('Error parsing ' + dataAttr + ' on ' + elem.className + ': ' + error);
          }
          return;
        }
        // initialize
        var instance = new WidgetClass(elem, options);
        // make available via $().data('namespace')
        if (jQuery) {
          jQuery.data(elem, namespace, instance);
        }
      });
    });
  };

  // -----  ----- //

  return utils;
});

/***/ }),

/***/ 17:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Flickity main
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(48), __webpack_require__(68), __webpack_require__(16), __webpack_require__(99), __webpack_require__(100), __webpack_require__(101)], __WEBPACK_AMD_DEFINE_RESULT__ = function (EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {
      return factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('ev-emitter'), require('get-size'), require('fizzy-ui-utils'), require('./cell'), require('./slide'), require('./animate'));
  } else {
    // browser global
    var _Flickity = window.Flickity;

    window.Flickity = factory(window, window.EvEmitter, window.getSize, window.fizzyUIUtils, _Flickity.Cell, _Flickity.Slide, _Flickity.animatePrototype);
  }
})(window, function factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {

  'use strict';

  // vars

  var jQuery = window.jQuery;
  var getComputedStyle = window.getComputedStyle;
  var console = window.console;

  function moveElements(elems, toElem) {
    elems = utils.makeArray(elems);
    while (elems.length) {
      toElem.appendChild(elems.shift());
    }
  }

  // -------------------------- Flickity -------------------------- //

  // globally unique identifiers
  var GUID = 0;
  // internal store of all Flickity intances
  var instances = {};

  function Flickity(element, options) {
    var queryElement = utils.getQueryElement(element);
    if (!queryElement) {
      if (console) {
        console.error('Bad element for Flickity: ' + (queryElement || element));
      }
      return;
    }
    this.element = queryElement;
    // do not initialize twice on same element
    if (this.element.flickityGUID) {
      var instance = instances[this.element.flickityGUID];
      instance.option(options);
      return instance;
    }

    // add jQuery
    if (jQuery) {
      this.$element = jQuery(this.element);
    }
    // options
    this.options = utils.extend({}, this.constructor.defaults);
    this.option(options);

    // kick things off
    this._create();
  }

  Flickity.defaults = {
    accessibility: true,
    // adaptiveHeight: false,
    cellAlign: 'center',
    // cellSelector: undefined,
    // contain: false,
    freeScrollFriction: 0.075, // friction when free-scrolling
    friction: 0.28, // friction when selecting
    namespaceJQueryEvents: true,
    // initialIndex: 0,
    percentPosition: true,
    resize: true,
    selectedAttraction: 0.025,
    setGallerySize: true
    // watchCSS: false,
    // wrapAround: false
  };

  // hash of methods triggered on _create()
  Flickity.createMethods = [];

  var proto = Flickity.prototype;
  // inherit EventEmitter
  utils.extend(proto, EvEmitter.prototype);

  proto._create = function () {
    // add id for Flickity.data
    var id = this.guid = ++GUID;
    this.element.flickityGUID = id; // expando
    instances[id] = this; // associate via id
    // initial properties
    this.selectedIndex = 0;
    // how many frames slider has been in same position
    this.restingFrames = 0;
    // initial physics properties
    this.x = 0;
    this.velocity = 0;
    this.originSide = this.options.rightToLeft ? 'right' : 'left';
    // create viewport & slider
    this.viewport = document.createElement('div');
    this.viewport.className = 'flickity-viewport';
    this._createSlider();

    if (this.options.resize || this.options.watchCSS) {
      window.addEventListener('resize', this);
    }

    Flickity.createMethods.forEach(function (method) {
      this[method]();
    }, this);

    if (this.options.watchCSS) {
      this.watchCSS();
    } else {
      this.activate();
    }
  };

  /**
   * set options
   * @param {Object} opts
   */
  proto.option = function (opts) {
    utils.extend(this.options, opts);
  };

  proto.activate = function () {
    if (this.isActive) {
      return;
    }
    this.isActive = true;
    this.element.classList.add('flickity-enabled');
    if (this.options.rightToLeft) {
      this.element.classList.add('flickity-rtl');
    }

    this.getSize();
    // move initial cell elements so they can be loaded as cells
    var cellElems = this._filterFindCellElements(this.element.children);
    moveElements(cellElems, this.slider);
    this.viewport.appendChild(this.slider);
    this.element.appendChild(this.viewport);
    // get cells from children
    this.reloadCells();

    if (this.options.accessibility) {
      // allow element to focusable
      this.element.tabIndex = 0;
      // listen for key presses
      this.element.addEventListener('keydown', this);
    }

    this.emitEvent('activate');

    var index;
    var initialIndex = this.options.initialIndex;
    if (this.isInitActivated) {
      index = this.selectedIndex;
    } else if (initialIndex !== undefined) {
      index = this.cells[initialIndex] ? initialIndex : 0;
    } else {
      index = 0;
    }
    // select instantly
    this.select(index, false, true);
    // flag for initial activation, for using initialIndex
    this.isInitActivated = true;
  };

  // slider positions the cells
  proto._createSlider = function () {
    // slider element does all the positioning
    var slider = document.createElement('div');
    slider.className = 'flickity-slider';
    slider.style[this.originSide] = 0;
    this.slider = slider;
  };

  proto._filterFindCellElements = function (elems) {
    return utils.filterFindElements(elems, this.options.cellSelector);
  };

  // goes through all children
  proto.reloadCells = function () {
    // collection of item elements
    this.cells = this._makeCells(this.slider.children);
    this.positionCells();
    this._getWrapShiftCells();
    this.setGallerySize();
  };

  /**
   * turn elements into Flickity.Cells
   * @param {Array or NodeList or HTMLElement} elems
   * @returns {Array} items - collection of new Flickity Cells
   */
  proto._makeCells = function (elems) {
    var cellElems = this._filterFindCellElements(elems);

    // create new Flickity for collection
    var cells = cellElems.map(function (cellElem) {
      return new Cell(cellElem, this);
    }, this);

    return cells;
  };

  proto.getLastCell = function () {
    return this.cells[this.cells.length - 1];
  };

  proto.getLastSlide = function () {
    return this.slides[this.slides.length - 1];
  };

  // positions all cells
  proto.positionCells = function () {
    // size all cells
    this._sizeCells(this.cells);
    // position all cells
    this._positionCells(0);
  };

  /**
   * position certain cells
   * @param {Integer} index - which cell to start with
   */
  proto._positionCells = function (index) {
    index = index || 0;
    // also measure maxCellHeight
    // start 0 if positioning all cells
    this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;
    var cellX = 0;
    // get cellX
    if (index > 0) {
      var startCell = this.cells[index - 1];
      cellX = startCell.x + startCell.size.outerWidth;
    }
    var len = this.cells.length;
    for (var i = index; i < len; i++) {
      var cell = this.cells[i];
      cell.setPosition(cellX);
      cellX += cell.size.outerWidth;
      this.maxCellHeight = Math.max(cell.size.outerHeight, this.maxCellHeight);
    }
    // keep track of cellX for wrap-around
    this.slideableWidth = cellX;
    // slides
    this.updateSlides();
    // contain slides target
    this._containSlides();
    // update slidesWidth
    this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;
  };

  /**
   * cell.getSize() on multiple cells
   * @param {Array} cells
   */
  proto._sizeCells = function (cells) {
    cells.forEach(function (cell) {
      cell.getSize();
    });
  };

  // --------------------------  -------------------------- //

  proto.updateSlides = function () {
    this.slides = [];
    if (!this.cells.length) {
      return;
    }

    var slide = new Slide(this);
    this.slides.push(slide);
    var isOriginLeft = this.originSide == 'left';
    var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';

    var canCellFit = this._getCanCellFit();

    this.cells.forEach(function (cell, i) {
      // just add cell if first cell in slide
      if (!slide.cells.length) {
        slide.addCell(cell);
        return;
      }

      var slideWidth = slide.outerWidth - slide.firstMargin + (cell.size.outerWidth - cell.size[nextMargin]);

      if (canCellFit.call(this, i, slideWidth)) {
        slide.addCell(cell);
      } else {
        // doesn't fit, new slide
        slide.updateTarget();

        slide = new Slide(this);
        this.slides.push(slide);
        slide.addCell(cell);
      }
    }, this);
    // last slide
    slide.updateTarget();
    // update .selectedSlide
    this.updateSelectedSlide();
  };

  proto._getCanCellFit = function () {
    var groupCells = this.options.groupCells;
    if (!groupCells) {
      return function () {
        return false;
      };
    } else if (typeof groupCells == 'number') {
      // group by number. 3 -> [0,1,2], [3,4,5], ...
      var number = parseInt(groupCells, 10);
      return function (i) {
        return i % number !== 0;
      };
    }
    // default, group by width of slide
    // parse '75%
    var percentMatch = typeof groupCells == 'string' && groupCells.match(/^(\d+)%$/);
    var percent = percentMatch ? parseInt(percentMatch[1], 10) / 100 : 1;
    return function (i, slideWidth) {
      return slideWidth <= (this.size.innerWidth + 1) * percent;
    };
  };

  // alias _init for jQuery plugin .flickity()
  proto._init = proto.reposition = function () {
    this.positionCells();
    this.positionSliderAtSelected();
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
    this.setCellAlign();
    this.cursorPosition = this.size.innerWidth * this.cellAlign;
  };

  var cellAlignShorthands = {
    // cell align, then based on origin side
    center: {
      left: 0.5,
      right: 0.5
    },
    left: {
      left: 0,
      right: 1
    },
    right: {
      right: 0,
      left: 1
    }
  };

  proto.setCellAlign = function () {
    var shorthand = cellAlignShorthands[this.options.cellAlign];
    this.cellAlign = shorthand ? shorthand[this.originSide] : this.options.cellAlign;
  };

  proto.setGallerySize = function () {
    if (this.options.setGallerySize) {
      var height = this.options.adaptiveHeight && this.selectedSlide ? this.selectedSlide.height : this.maxCellHeight;
      this.viewport.style.height = height + 'px';
    }
  };

  proto._getWrapShiftCells = function () {
    // only for wrap-around
    if (!this.options.wrapAround) {
      return;
    }
    // unshift previous cells
    this._unshiftCells(this.beforeShiftCells);
    this._unshiftCells(this.afterShiftCells);
    // get before cells
    // initial gap
    var gapX = this.cursorPosition;
    var cellIndex = this.cells.length - 1;
    this.beforeShiftCells = this._getGapCells(gapX, cellIndex, -1);
    // get after cells
    // ending gap between last cell and end of gallery viewport
    gapX = this.size.innerWidth - this.cursorPosition;
    // start cloning at first cell, working forwards
    this.afterShiftCells = this._getGapCells(gapX, 0, 1);
  };

  proto._getGapCells = function (gapX, cellIndex, increment) {
    // keep adding cells until the cover the initial gap
    var cells = [];
    while (gapX > 0) {
      var cell = this.cells[cellIndex];
      if (!cell) {
        break;
      }
      cells.push(cell);
      cellIndex += increment;
      gapX -= cell.size.outerWidth;
    }
    return cells;
  };

  // ----- contain ----- //

  // contain cell targets so no excess sliding
  proto._containSlides = function () {
    if (!this.options.contain || this.options.wrapAround || !this.cells.length) {
      return;
    }
    var isRightToLeft = this.options.rightToLeft;
    var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';
    var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';
    var contentWidth = this.slideableWidth - this.getLastCell().size[endMargin];
    // content is less than gallery size
    var isContentSmaller = contentWidth < this.size.innerWidth;
    // bounds
    var beginBound = this.cursorPosition + this.cells[0].size[beginMargin];
    var endBound = contentWidth - this.size.innerWidth * (1 - this.cellAlign);
    // contain each cell target
    this.slides.forEach(function (slide) {
      if (isContentSmaller) {
        // all cells fit inside gallery
        slide.target = contentWidth * this.cellAlign;
      } else {
        // contain to bounds
        slide.target = Math.max(slide.target, beginBound);
        slide.target = Math.min(slide.target, endBound);
      }
    }, this);
  };

  // -----  ----- //

  /**
   * emits events via eventEmitter and jQuery events
   * @param {String} type - name of event
   * @param {Event} event - original event
   * @param {Array} args - extra arguments
   */
  proto.dispatchEvent = function (type, event, args) {
    var emitArgs = event ? [event].concat(args) : args;
    this.emitEvent(type, emitArgs);

    if (jQuery && this.$element) {
      // default trigger with type if no event
      type += this.options.namespaceJQueryEvents ? '.flickity' : '';
      var $event = type;
      if (event) {
        // create jQuery event
        var jQEvent = jQuery.Event(event);
        jQEvent.type = type;
        $event = jQEvent;
      }
      this.$element.trigger($event, args);
    }
  };

  // -------------------------- select -------------------------- //

  /**
   * @param {Integer} index - index of the slide
   * @param {Boolean} isWrap - will wrap-around to last/first if at the end
   * @param {Boolean} isInstant - will immediately set position at selected cell
   */
  proto.select = function (index, isWrap, isInstant) {
    if (!this.isActive) {
      return;
    }
    index = parseInt(index, 10);
    this._wrapSelect(index);

    if (this.options.wrapAround || isWrap) {
      index = utils.modulo(index, this.slides.length);
    }
    // bail if invalid index
    if (!this.slides[index]) {
      return;
    }
    this.selectedIndex = index;
    this.updateSelectedSlide();
    if (isInstant) {
      this.positionSliderAtSelected();
    } else {
      this.startAnimation();
    }
    if (this.options.adaptiveHeight) {
      this.setGallerySize();
    }

    this.dispatchEvent('select');
    // old v1 event name, remove in v3
    this.dispatchEvent('cellSelect');
  };

  // wraps position for wrapAround, to move to closest slide. #113
  proto._wrapSelect = function (index) {
    var len = this.slides.length;
    var isWrapping = this.options.wrapAround && len > 1;
    if (!isWrapping) {
      return index;
    }
    var wrapIndex = utils.modulo(index, len);
    // go to shortest
    var delta = Math.abs(wrapIndex - this.selectedIndex);
    var backWrapDelta = Math.abs(wrapIndex + len - this.selectedIndex);
    var forewardWrapDelta = Math.abs(wrapIndex - len - this.selectedIndex);
    if (!this.isDragSelect && backWrapDelta < delta) {
      index += len;
    } else if (!this.isDragSelect && forewardWrapDelta < delta) {
      index -= len;
    }
    // wrap position so slider is within normal area
    if (index < 0) {
      this.x -= this.slideableWidth;
    } else if (index >= len) {
      this.x += this.slideableWidth;
    }
  };

  proto.previous = function (isWrap, isInstant) {
    this.select(this.selectedIndex - 1, isWrap, isInstant);
  };

  proto.next = function (isWrap, isInstant) {
    this.select(this.selectedIndex + 1, isWrap, isInstant);
  };

  proto.updateSelectedSlide = function () {
    var slide = this.slides[this.selectedIndex];
    // selectedIndex could be outside of slides, if triggered before resize()
    if (!slide) {
      return;
    }
    // unselect previous selected slide
    this.unselectSelectedSlide();
    // update new selected slide
    this.selectedSlide = slide;
    slide.select();
    this.selectedCells = slide.cells;
    this.selectedElements = slide.getCellElements();
    // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility
    // Remove in v3?
    this.selectedCell = slide.cells[0];
    this.selectedElement = this.selectedElements[0];
  };

  proto.unselectSelectedSlide = function () {
    if (this.selectedSlide) {
      this.selectedSlide.unselect();
    }
  };

  /**
   * select slide from number or cell element
   * @param {Element or Number} elem
   */
  proto.selectCell = function (value, isWrap, isInstant) {
    // get cell
    var cell;
    if (typeof value == 'number') {
      cell = this.cells[value];
    } else {
      // use string as selector
      if (typeof value == 'string') {
        value = this.element.querySelector(value);
      }
      // get cell from element
      cell = this.getCell(value);
    }
    // select slide that has cell
    for (var i = 0; cell && i < this.slides.length; i++) {
      var slide = this.slides[i];
      var index = slide.cells.indexOf(cell);
      if (index != -1) {
        this.select(i, isWrap, isInstant);
        return;
      }
    }
  };

  // -------------------------- get cells -------------------------- //

  /**
   * get Flickity.Cell, given an Element
   * @param {Element} elem
   * @returns {Flickity.Cell} item
   */
  proto.getCell = function (elem) {
    // loop through cells to get the one that matches
    for (var i = 0; i < this.cells.length; i++) {
      var cell = this.cells[i];
      if (cell.element == elem) {
        return cell;
      }
    }
  };

  /**
   * get collection of Flickity.Cells, given Elements
   * @param {Element, Array, NodeList} elems
   * @returns {Array} cells - Flickity.Cells
   */
  proto.getCells = function (elems) {
    elems = utils.makeArray(elems);
    var cells = [];
    elems.forEach(function (elem) {
      var cell = this.getCell(elem);
      if (cell) {
        cells.push(cell);
      }
    }, this);
    return cells;
  };

  /**
   * get cell elements
   * @returns {Array} cellElems
   */
  proto.getCellElements = function () {
    return this.cells.map(function (cell) {
      return cell.element;
    });
  };

  /**
   * get parent cell from an element
   * @param {Element} elem
   * @returns {Flickit.Cell} cell
   */
  proto.getParentCell = function (elem) {
    // first check if elem is cell
    var cell = this.getCell(elem);
    if (cell) {
      return cell;
    }
    // try to get parent cell elem
    elem = utils.getParent(elem, '.flickity-slider > *');
    return this.getCell(elem);
  };

  /**
   * get cells adjacent to a slide
   * @param {Integer} adjCount - number of adjacent slides
   * @param {Integer} index - index of slide to start
   * @returns {Array} cells - array of Flickity.Cells
   */
  proto.getAdjacentCellElements = function (adjCount, index) {
    if (!adjCount) {
      return this.selectedSlide.getCellElements();
    }
    index = index === undefined ? this.selectedIndex : index;

    var len = this.slides.length;
    if (1 + adjCount * 2 >= len) {
      return this.getCellElements();
    }

    var cellElems = [];
    for (var i = index - adjCount; i <= index + adjCount; i++) {
      var slideIndex = this.options.wrapAround ? utils.modulo(i, len) : i;
      var slide = this.slides[slideIndex];
      if (slide) {
        cellElems = cellElems.concat(slide.getCellElements());
      }
    }
    return cellElems;
  };

  // -------------------------- events -------------------------- //

  proto.uiChange = function () {
    this.emitEvent('uiChange');
  };

  proto.childUIPointerDown = function (event) {
    this.emitEvent('childUIPointerDown', [event]);
  };

  // ----- resize ----- //

  proto.onresize = function () {
    this.watchCSS();
    this.resize();
  };

  utils.debounceMethod(Flickity, 'onresize', 150);

  proto.resize = function () {
    if (!this.isActive) {
      return;
    }
    this.getSize();
    // wrap values
    if (this.options.wrapAround) {
      this.x = utils.modulo(this.x, this.slideableWidth);
    }
    this.positionCells();
    this._getWrapShiftCells();
    this.setGallerySize();
    this.emitEvent('resize');
    // update selected index for group slides, instant
    // TODO: position can be lost between groups of various numbers
    var selectedElement = this.selectedElements && this.selectedElements[0];
    this.selectCell(selectedElement, false, true);
  };

  // watches the :after property, activates/deactivates
  proto.watchCSS = function () {
    var watchOption = this.options.watchCSS;
    if (!watchOption) {
      return;
    }

    var afterContent = getComputedStyle(this.element, ':after').content;
    // activate if :after { content: 'flickity' }
    if (afterContent.indexOf('flickity') != -1) {
      this.activate();
    } else {
      this.deactivate();
    }
  };

  // ----- keydown ----- //

  // go previous/next if left/right keys pressed
  proto.onkeydown = function (event) {
    // only work if element is in focus
    if (!this.options.accessibility || document.activeElement && document.activeElement != this.element) {
      return;
    }

    if (event.keyCode == 37) {
      // go left
      var leftMethod = this.options.rightToLeft ? 'next' : 'previous';
      this.uiChange();
      this[leftMethod]();
    } else if (event.keyCode == 39) {
      // go right
      var rightMethod = this.options.rightToLeft ? 'previous' : 'next';
      this.uiChange();
      this[rightMethod]();
    }
  };

  // -------------------------- destroy -------------------------- //

  // deactivate all Flickity functionality, but keep stuff available
  proto.deactivate = function () {
    if (!this.isActive) {
      return;
    }
    this.element.classList.remove('flickity-enabled');
    this.element.classList.remove('flickity-rtl');
    // destroy cells
    this.cells.forEach(function (cell) {
      cell.destroy();
    });
    this.unselectSelectedSlide();
    this.element.removeChild(this.viewport);
    // move child elements back into element
    moveElements(this.slider.children, this.element);
    if (this.options.accessibility) {
      this.element.removeAttribute('tabIndex');
      this.element.removeEventListener('keydown', this);
    }
    // set flags
    this.isActive = false;
    this.emitEvent('deactivate');
  };

  proto.destroy = function () {
    this.deactivate();
    window.removeEventListener('resize', this);
    this.emitEvent('destroy');
    if (jQuery && this.$element) {
      jQuery.removeData(this.element, 'flickity');
    }
    delete this.element.flickityGUID;
    delete instances[this.guid];
  };

  // -------------------------- prototype -------------------------- //

  utils.extend(proto, animatePrototype);

  // -------------------------- extras -------------------------- //

  /**
   * get Flickity instance from element
   * @param {Element} elem
   * @returns {Flickity}
   */
  Flickity.data = function (elem) {
    elem = utils.getQueryElement(elem);
    var id = elem && elem.flickityGUID;
    return id && instances[id];
  };

  utils.htmlInit(Flickity, 'flickity');

  if (jQuery && jQuery.bridget) {
    jQuery.bridget('flickity', Flickity);
  }

  // set internal jQuery, for Webpack + jQuery v3, #478
  Flickity.setJQuery = function (jq) {
    jQuery = jq;
  };

  Flickity.Cell = Cell;

  return Flickity;
});

/***/ }),

/***/ 295:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(296);


/***/ }),

/***/ 296:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(78);

window.ccPages = {
    onActivatePageReady: __webpack_require__(352),
    onJoinPageReady: __webpack_require__(353),
    onEditProfilePageReady: __webpack_require__(354),
    onForgotPasswordPageReady: __webpack_require__(355),
    onLandingPageReady: __webpack_require__(356),
    onMemberBenefitsPageReady: __webpack_require__(357),
    onPersonalInformationPageReady: __webpack_require__(358),
    onPreferencesPageReady: __webpack_require__(359),
    onResetConfirmationPageReady: __webpack_require__(360),
    // onResetPasswordPageReady: require('./cc-reset-password'),
    onECertsPageReady: __webpack_require__(361),
    onMyAccountPageReady: __webpack_require__(362),
    onReservationsPageReady: __webpack_require__(363),
    onStatementPageReady: __webpack_require__(364),
    onCancelReservationPageReady: __webpack_require__(365)
};

/***/ }),

/***/ 352:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var $ = __webpack_require__(2);
var parsley = __webpack_require__(66);
var referrer = __webpack_require__(67);
var queryString = __webpack_require__(60);

/* globals LANG KEY_PAGES */
module.exports = function HandleCCActivatePageReady() {
    $(".primarynav li:nth-child(5)").addClass("active");

    var queryVarWebuid = queryString.webuid;
    var queryVarToken = queryString.token;
    if (queryVarWebuid && queryVarToken) {
        // send activation request
        // console.log("Handling activation");
        $('.loader-wrapper').addClass('visible');
        var url = '/ajax/activate?webuid=' + queryVarWebuid + '&token=' + queryVarToken;
        $.getJSON(url, function (response) {
            // console.log("ACTIVATION DATA RETURNED:", url, response);
            if (response.data.record == 'Account activated') {
                window.location.href = KEY_PAGES['login'][LANG] + '?activated=1';
            } else {
                // console.log("Account was not activated. Sending error message (" + response.data.record + ") to", $('.signup-results .result'));
                $('.loader-wrapper').removeClass('visible');
                $('.signup-results .result').text(response.data.record);
            }
        });
    } else {
        // handle activation form
        if (typeof $('#activate-form').parsley() !== 'undefined') {
            $('#activate-form').parsley().on('field:validated', function () {
                if ($('#activate-form').parsley().isValid()) {
                    $('#activate-form button.primary').prop('disabled', false);
                } else {
                    $('#activate-form button.primary').prop('disabled', true);
                }
            });
        }

        referrer.popLastPage();
        validatePass();
        getStates();

        $('#country').on('change', changeStates);
        $('.show-pass').click(togglePasswordFields);

        $('.show-pass').keydown(function (e) {
            if (e.which === 13) {
                $(this).click();
            }
        });

        $('#activate-form').submit(function (e) {
            // console.log("Handling Submit");

            // Stop default form action so we can do an ajax POST
            e.preventDefault();

            if ($(this).parsley().validate()) {
                handleSubmit(e);
            }

            return false;
        });
    }

    var statesList = [];
    function getStates() {
        $.ajax({
            url: '/ajax/states',
            type: 'get',
            dataType: 'json',
            success: function success(response) {
                for (var i = response.data.record.length - 1; i >= 0; i--) {
                    if (response.data.record[i].name && response.data.record[i].code && response.data.record[i].status == '1') {
                        if (!statesList[response.data.record[i].country]) {
                            statesList[response.data.record[i].country] = [];
                        }
                        if (_typeof(response.data.record[i].name) === 'object') {
                            response.data.record[i].name = response.data.record[i].code;
                        }
                        statesList[response.data.record[i].country].push({ 'abbreviation': response.data.record[i].code, 'name': response.data.record[i].name });
                    }
                }

                $('#country').trigger('change');
            }
        });
    }

    function changeStates(event) {
        var target = event.target;
        var selectedCountry = $(event.currentTarget).children(':selected').text();
        var unsortedStates;
        var sortedStates;

        if (statesList[selectedCountry]) {
            unsortedStates = statesList[selectedCountry];
            sortedStates = Array.apply(null, unsortedStates).sort(function (a, b) {
                return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
            });
        } else {
            sortedStates = [{ abbreviation: 'other', name: 'Other' }];
        }

        var options = $.map(sortedStates, function (option) {
            var text, value, ret;
            if (!option.name && !option.abbreviation) {
                return false;
            } else {
                // since our data isn't all that great, use one to cover the gaps in the other
                value = _typeof(option.abbreviation) !== 'object' ? option.abbreviation : option.name;
                text = _typeof(option.name) !== 'object' ? option.name : option.abbreviation;

                ret = '<option value="' + value + '"' + ($('#state').attr('data-value') === value ? ' selected' : '') + '>' + text + '</option>';
                return ret;
            }
        });
        options.splice(0, 0, '<option value disabled selected>' + (selectedCountry === 'Canada' ? 'Select a Province' : 'Select a State') + '</option>');

        $('#state').html(options);

        // Update country code for phone based on country, then revalidate
        $('#countrycode').val(target.options[target.selectedIndex].getAttribute('data-phonecode')).parsley().validate();
    }

    function togglePasswordFields() {
        var passwordFields = $('#password, #password2');
        var passwordLabels = $('.show-pass');

        var currentLabel = $(passwordLabels[0]).text();
        var currentType = passwordFields[0].type;

        passwordFields.prop('type', currentType === 'password' && 'text' || 'password');
        passwordLabels.text(currentLabel === 'Show Password' && 'Hide Password' || 'Show Password');
    }

    function handleSubmit() {
        var userid = encodeURIComponent($('#activate-form input[name=userid]').val());
        var formData = $('#activate-form').serialize() + '&email=' + userid;

        $('.loader-wrapper').addClass('visible');

        $.ajax({
            url: '/ajax/send-activation-email?email=' + userid,
            type: 'POST',
            dataType: 'json',
            data: formData,
            encode: true,
            success: function success(response) {
                console.log("AJAX response:", response);
                if (response.data.message === 'Activation request sent') {
                    window.location.href = KEY_PAGES['activation-email-sent'][LANG];
                } else {
                    $('.loader-wrapper').removeClass('visible');
                    $('html, body').animate({
                        scrollTop: $("#form-error").offset().top
                    }, 2000);
                    $('#form-error').fadeIn().html(response.data.errors.record).delay(5000).fadeOut();
                    window.trackFormError(response.data.errors.record);
                    return false;
                }
            },
            error: function error(err) {
                console.log(err);
            }

        });
        return false;
    }

    function validatePass() {
        $('#password, #textPassword').on('keyup', function () {
            $('.password-requirements').addClass('visible');
            var password = $(this).val();
            var passLength = $('.password-length');
            var passNumber = $('.password-contains-number');
            var passLowercase = $('.password-contains-lowercase');
            var passUppercase = $('.password-contains-uppercase');

            // validate the length
            if (password.length >= 8 && password.length <= 20) {
                passLength.addClass('passed');
            } else {
                passLength.removeClass('passed');
            }

            // validate number
            if (password.match(/[0-9]/)) {
                passNumber.addClass('passed');
            } else {
                passNumber.removeClass('passed');
            }

            // validate lowercase letter
            if (password.match(/[a-z]/)) {
                passLowercase.addClass('passed');
            } else {
                passLowercase.removeClass('passed');
            }

            // validate uppercase letter
            if (password.match(/[A-Z]/)) {
                passUppercase.addClass('passed');
            } else {
                passUppercase.removeClass('passed');
            }

            // Prevents password requirements from flashing on focus/blur
            var mousedownHappened = false;

            $('#password').on('blur', function () {
                if (mousedownHappened) {
                    // cancel the blur event
                    $('#password').focus();
                    mousedownHappened = false;
                } else {
                    // blur event is okay
                    $('.password-requirements').removeClass('visible');
                }
            });

            $('.show-pass').on('mousedown', function () {
                mousedownHappened = true;
            });
        });
    }
};

/***/ }),

/***/ 353:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var $ = __webpack_require__(2);
var userPermissions = __webpack_require__(61);
var referrer = __webpack_require__(67);
var parsley = __webpack_require__(66);
var sessionStorage = __webpack_require__(80);

/* globals LANG KEY_PAGES PAGEINFO BRAND USERINFO TRANSLATIONS */

module.exports = function handleJoinPageReady() {
	return new CCJoinPage();

	function CCJoinPage() {
		var self = this;

		var utag = window.utag;

		self.urlParams = getUrlParameters();
		self.eligibleCountries = ["BD", "BR", "CO", "DK", "FR", "GB", "IE", "IN", "JO", "KW", "LB", "MX", "NL", "RU", "SA", "SG", "TH", "TR", "US", "PA", "CR", "CA", "PH", "AU", "QA", "AE", "EG", "CL", "BH", "LY", "PE", "OM"];

		$('#signup-form').parsley().on('field:validated', function () {
			if ($('#signup-form').parsley().isValid()) {
				$('#signup-form button.primary').removeClass('disabled');
			} else {
				$('#signup-form button.primary').addClass('disabled');
			}
		});

		referrer.popLastPage();
		getStates();

		$('.join-modal-close').attr('href', function () {
			if (referrer.lastPageVisited(1) && referrer.lastPageVisited(1).url !== '') {
				return referrer.lastPageVisited(1).url;
			} else {
				return KEY_PAGES['club-carlson'][LANG];
			}
		});

		$('#promo').val(self.urlParams.enrollmentcode);
		$('#country').on('change', changeStates);
		$('#userid').on('blur', checkEmail);
		$('#phone').on('change', formatPhone);
		$('.close-btn').click(closeTravelersOverlay);
		$('#signup-form').submit(handleSubmit);
		$('.show-pass').click(togglePasswordFields).keydown(handleShowPasswordKeyPress);

		$('#password').on('keydown', function () {
			setTimeout(isPasswordValid, 50);
		}).on('focus', function () {
			showPasswordRequirements(true);
		}).on('blur', function () {
			showPasswordRequirements(false);
		});

		isPasswordValid();

		if ($(window).scrollTop() !== 0) {
			$(window).scrollTop(0);
		}

		function getUrlParameters() {
			var params = window.location.search.replace('?', '').split('&').reduce(function (sum, n) {
				var segments = n.split('=');
				if (segments.length === 2) {
					sum[decodeURIComponent(segments[0])] = decodeURIComponent(segments[1]);
				}
				return sum;
			}, {});
			return params;
		}

		function handleShowPasswordKeyPress(e) {
			if (e.which === 13) {
				$(this).click();
			}
		}

		function togglePasswordFields() {
			var passwordFields = $('#password, #password2');
			var passwordLabels = $('.show-pass');

			var currentLabel = $(passwordLabels[0]).text();
			var currentType = passwordFields[0].type;

			passwordFields.prop('type', currentType === 'password' && 'text' || 'password');
			passwordLabels.text(currentLabel === 'Show Password' && 'Hide Password' || 'Show Password');
		}

		function showPasswordRequirements(visibility) {
			$('.password-requirements').toggleClass('visible', visibility);
		}

		function checkEmail() {
			var emailField = {
				'email': decodeURIComponent(self.urlParams.userid)
			};

			$.ajax({
				url: '/ajax/check-email',
				type: 'POST',
				data: emailField,
				dataType: 'json',
				encode: true,
				success: function success(response) {
					// account exists, show password field
					if (response.data.record[0] === "Account exists, proceed to activation screen") {
						self.user = response.data.record[1];
						$('#email-exists-error').show();
						window.trackFormError(response.data.record[0]);
					} else {
						$('#email-exists-error').hide();
					}
				}
			});
		}

		function isPasswordValid(passwordArg) {
			var password = passwordArg || $('#password').val();

			var returnValue = true;
			var passLength = $('.password-length');
			var passNumber = $('.password-contains-number');
			var passUppercase = $('.password-contains-uppercase');
			var passLowercase = $('.password-contains-lowercase');

			// validate the length
			if (password.length >= 8 && password.length <= 20) {
				passLength.addClass('passed');
			} else {
				passLength.removeClass('passed');
				returnValue = false;
			}

			// validate number
			if (password.match(/[0-9]/)) {
				passNumber.addClass('passed');
			} else {
				passNumber.removeClass('passed');
				returnValue = false;
			}

			// validate lowercase letter
			if (password.match(/[a-z]/)) {
				passLowercase.addClass('passed');
			} else {
				returnValue = false;
				passLowercase.removeClass('passed');
			}

			// validate uppercase letter
			if (password.match(/[A-Z]/)) {
				passUppercase.addClass('passed');
			} else {
				returnValue = false;
				passUppercase.removeClass('passed');
			}

			return returnValue;
		}

		function formatPhone(event) {
			// Get phone number from form and add to phone object as value
			var numbers, char;
			var phone = { 'value': $(event.currentTarget).val() };
			// Test against simple regex and add dash after 3rd character
			numbers = phone.value.replace(/\D/g, '');
			char = { 3: '' };
			// Set phone value to empty string
			phone.value = '';
			// Update phone value with correct formatting
			for (var i = 0; i < numbers.length; i++) {
				phone.value += (char[i] || '') + numbers[i];
			}
			// Set input value to formatted phone number
			$(event.currentTarget).val(phone.value);
		}

		var statesList = [];

		function getStates() {
			$.ajax({
				url: '/ajax/states',
				type: 'get',
				dataType: 'json',
				success: function success(response) {
					for (var i = response.data.record.length - 1; i >= 0; i--) {
						if (response.data.record[i].name && response.data.record[i].code && response.data.record[i].status == '1') {
							if (!statesList[response.data.record[i].country]) {
								statesList[response.data.record[i].country] = [];
							}
							if (_typeof(response.data.record[i].name) === 'object') {
								response.data.record[i].name = response.data.record[i].code;
							}
							statesList[response.data.record[i].country].push({
								'abbreviation': response.data.record[i].code,
								'name': response.data.record[i].name
							});
						}
					}

					$('#country').trigger('change');
				}
			});
		}

		function changeStates(event) {
			var target = event.target;
			var selectedCountry = $(event.currentTarget).children(':selected').text();
			var selectedCountryCode = $(event.currentTarget).val();
			var stateText = $('#state').data('state');
			var provinceText = $('#state').data('province');
			var unsortedStates;
			var sortedStates;

			if (statesList[selectedCountry]) {
				unsortedStates = statesList[selectedCountry];
				sortedStates = Array.apply(null, unsortedStates).sort(function (a, b) {
					return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
				});
			} else {
				sortedStates = [{ abbreviation: 'other', name: 'Other' }];
			}

			var options = $.map(sortedStates, function (option) {
				var text, value, ret;
				if (!option.name && !option.abbreviation) {
					return false;
				} else {
					// since our data isn't all that great, use one to cover the gaps in the other
					value = _typeof(option.abbreviation) !== 'object' ? option.abbreviation : option.name;
					text = _typeof(option.name) !== 'object' ? option.name : option.abbreviation;

					ret = '<option value="' + value + '"' + ($('#state').attr('data-value') === value ? ' selected' : '') + '>' + text + '</option>';
					return ret;
				}
			});

			options.splice(0, 0, '<option value disabled selected>' + (selectedCountryCode === 'CA' ? provinceText : stateText) + '</option>');

			$('#state').html(options);

			// Update country code for phone based on country, then revalidate
			$('#countrycode').val(target.options[target.selectedIndex].getAttribute('data-phonecode')).parsley().validate();
		}

		function handleSubmit(e) {
			e.preventDefault();

			if (!$('.loader-wrapper').length) {
				// console.log('adding loading animation to dom');
				var loader = $('<div class="loader-wrapper visible"><div class="loader"><div></div><div></div><div></div></div></div>');
				loader.appendTo('body');
			} else {
				$('.loader-wrapper').addClass('visible');
			}

			var signupFormData = $('#signup-form').serializeArray().reduce(function (sum, pair) {
				sum[pair.name] = pair.value;
				return sum;
			}, {});

			if ($('#memberType').val() === 'Travel Arranger' && $.inArray(signupFormData.country, self.eligibleCountries) === -1) {
				openTravelersOverlay();
				return false;
			}

			signupFormData.optin = signupFormData.optin === 'on' && "no" || "on";
			var optedIn = false;
			if ($('input#optin').is(':checked')) {
				optedIn = true;
			}

			$.ajax({
				url: '/ajax/sign-up',
				type: 'POST',
				data: signupFormData,
				dataType: 'json',
				success: function success(response) {
					// console.log('received', response);

					if (response.data.errors) {
						$('.loader-wrapper').removeClass('visible');
						$('#signup-form .form-errors').fadeIn().html(response.data.errors.record).delay(5000).fadeOut();
						window.trackFormError(response.data.errors.record);
					} else if (response.data.message === 'guest enrolled') {
						var loginData = {
							username: signupFormData.userid,
							password: signupFormData.password
						};
						if (userPermissions.permissions.canTrackMe && typeof window.utag !== 'undefined') {
							var utagViewInfo = {
								'page.pageInfo.pageName': "joinClubCarlsonConfirmationPage",
								'page.pageInfo.primaryCategory': PAGEINFO.primaryCategory,
								'page.pageInfo.pagePath': PAGEINFO.pagePath,
								'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
								'page.pageInfo.referringURL': PAGEINFO.referringURL,
								'page.pageInfo.language': PAGEINFO.language,
								'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
								'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
								'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
								'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
								'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
								'page.pageInfo.timeZone': PAGEINFO.timezone,
								'page.pageInfo.brand': 'club-carlson',
								'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
								'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
								'page.pageInfo.bvCode': PAGEINFO.bvCode,
								'page.pageInfo.isWebview': PAGEINFO.isWebView,
								'user.userInfo.userID': USERINFO.userId,
								'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier,
								'user.userInfo.authentication': '1'
							};
							var utagLinkInfo = {
								'eventTracking.eventName': 'Complete Your Profile Form Submission',
								'form.formUserCountry': signupFormData.country,
								'form.formUserState': signupFormData.state,
								'form.formUserCity': signupFormData.city,
								'form.formUserPostal': signupFormData.zipcode,
								'clubCarlson.loyaltyActivation': '1',
								'user.userInfo.emailOptIn': optedIn ? '1' : '0',
								'user.userInfo.authentication': '1'
							};
							window.utag.link(utagLinkInfo, function () {
								window.utag.view(utagViewInfo);
							});
						}
						if (response.data.profile.memberTypes.record === "Travel Arranger") {
							window.utag.link({
								'eventInfo.eventName': 'Travel Arrangers Program Enrollment'
							});
						} else if (response.data.profile.memberTypes.record === "Planner") {
							window.utag.link({
								'eventInfo.eventName': 'Professional Planners Program Enrollment'
							});
						}

						$.ajax({
							url: '/ajax/login',
							type: 'POST',
							data: loginData,
							dataType: 'json',
							success: function success(response) {
								sessionStorage.setItem('cacheData', JSON.stringify(response.data));

								$('#cc-join-confirm-id').text(response.data.loyaltyNumber);
								$('.confirmation-block').removeClass('hidden');
								$('.join-block').addClass('hidden');

								var lastPageVisited = referrer && referrer.lastPageVisited(1);
								var returnButtonText;
								if (lastPageVisited.title && lastPageVisited.title !== '' && lastPageVisited.url !== KEY_PAGES['club-carlson'][LANG]) {
									returnButtonText = $('#returnToReferrerButton').text().replace('${PageName}', lastPageVisited.title);
									$('#returnToReferrerButton').attr('href', lastPageVisited.url).text(returnButtonText).removeClass('hidden');
								} else if (!lastPageVisited.title) {
									returnButtonText = TRANSLATIONS['return-to-home-page'];
									$('#returnToReferrerButton').attr('href', '/' + LANG).text(returnButtonText).removeClass('hidden');
								}

								$('#returnToClubCarlsonButton').removeClass('hidden');
								$('.loader-wrapper').removeClass('visible');
								/*
        // qa comment - was this was being called  twice
                                window.utag.view({
                                    'page.pageInfo.pageName':  "joinClubCarlsonConfirmationPage",
                                    'page.pageInfo.primaryCategory': PAGEINFO.primaryCategory,
                                    'page.pageInfo.pagePath': PAGEINFO.pagePath,
                                    'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
                                    'page.pageInfo.referringURL': PAGEINFO.referringURL,
                                    'page.pageInfo.language': PAGEINFO.language,
                                    'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
                                    'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
                                    'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
                                    'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
                                    'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
                                    'page.pageInfo.timeZone': PAGEINFO.timezone,
                                    'page.pageInfo.brand': BRAND.slug,
                                    'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
                                    'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
                                    'page.pageInfo.bvCode': PAGEINFO.bvCode,
                                    'page.pageInfo.isWebview': PAGEINFO.isWebView,
                                    'user.userInfo.userID': USERINFO.userId,
                                    'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier,
                                    'user.userInfo.authentication': '0'
                                });
                                */
							}
						});
					} else {
						$('.loader-wrapper').removeClass('visible');
						if (userPermissions.permissions.canTrackMe && typeof window.utag !== 'undefined') {
							window.utag.link({
								'eventTracking.eventName': 'Complete Your Profile Form Submission',
								'form.formErrorValue': response.data.record
							}, function () {
								// console.log("Complete Your Profile form error has been tracked");
							});
						}
					}
				}
			});
		}

		function closeTravelersOverlay() {
			$('.modal-overlay').addClass('hidden');
		}

		function openTravelersOverlay() {
			$('.modal-overlay').removeClass('hidden');
		}
	}
};

/***/ }),

/***/ 354:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var $ = __webpack_require__(2);
var mobileNav = __webpack_require__(47);
var parsley = __webpack_require__(66);
var Cookies = __webpack_require__(46);

/* globals LANG KEY_PAGES */

module.exports = function handleCCEditProfilePageReady() {
	return new CCEditProfilePage();

	function CCEditProfilePage() {

		var self = this;
		var localStorage = window.localStorage;

		var utag = window.utag;
		var referrer = window.referrer;

		self.urlParams = getUrlParameters();
		self.eligibleCountries = ["SAU", "SGP", "THA", "TUR", "USA", "PAN", "CRI", "CAN", "PHL", "AUS", "QAT", "ARE", "EGY", "CHL", "BHR", "LBY", "PER", "OMN"];

		if (!$('.loader-wrapper').length) {
			console.log('adding loading animation to dom');
			var loader = $('<div class="loader-wrapper"><div class="loader"><div></div><div></div><div></div></div></div>');
			loader.appendTo('body');
		}

		$('#edit-personal-info').parsley().on('field:validated', function () {
			if ($('#edit-personal-info').parsley().isValid()) {
				$('#edit-personal-info button.primary').removeClass('disabled');
			} else {
				$('#edit-personal-info button.primary').addClass('disabled');
			}
		});

		$('#edit-password').parsley().on('field:validated', function () {
			if ($('#edit-password').parsley().isValid()) {
				$('#edit-password button.primary').prop('disabled', false);
			} else {
				$('#edit-password button.primary').prop('disabled', true);
			}
		});

		// Activate side nav tab (static for now)
		$(".account-nav li:nth-child(3) a").addClass("active");
		mobileNav();
		getStates();

		$('#country').on('change', changeStates);
		$('#userid').on('blur', checkEmail);
		$('button.secondary').click(cancelPage);
		$('.close-btn').click(closeTravelersOverlay);

		$('#edit-personal-info').submit(handleSubmit('#edit-personal-info'));
		$('#edit-password').submit(handleSubmit('#edit-password'));

		$('.show-pass').click(function (e) {
			togglePasswordFields($('.show-pass').index(this));
		});
		$('.show-pass').keydown(function (e) {
			if (e.which === 13) {
				$(this).click();
			}
		});
		$('#password').on('keydown', function () {
			setTimeout(isPasswordValid, 50);
		}).on('focus', function () {
			showPasswordRequirements(true);
		}).on('blur', function () {
			showPasswordRequirements(false);
		});

		isPasswordValid();

		function getUrlParameters() {
			var params = window.location.search.replace('?', '').split('&').reduce(function (sum, n) {
				var segments = n.split('=');
				if (segments.length === 2) {
					sum[decodeURIComponent(segments[0])] = decodeURIComponent(segments[1]);
				}
				return sum;
			}, {});
			return params;
		}

		function cancelPage() {
			window.location.reload();
		}

		function togglePasswordFields(index) {
			var passwordFields = [$('#currentpassword'), $('#password'), $('#password2')];
			var passwordLabel = $("span.show-pass").eq(index);
			var currentLabel = passwordLabel.text();
			var currentType = passwordFields[index].attr('type');
			passwordFields[index].prop('type', currentType === 'password' ? 'text' : 'password');
			passwordLabel.text(currentLabel === 'Show Password' ? 'Hide Password' : 'Show Password');
		}

		// function trimSpace() {
		//     $('#signup-form input#userid').on('change', function() {
		//         $(this).val($(this).val().replace(/\s/g,""));
		//     });
		// }

		function showPasswordRequirements(visibility) {
			$('.password-requirements').toggleClass('visible', visibility);
		}
		function checkEmail() {
			var emailField = {
				'email': decodeURIComponent(self.urlParam.userid)
			};

			$.ajax({
				url: '/ajax/check-email',
				type: 'POST',
				data: emailField,
				dataType: 'json',
				encode: true,
				success: function success(response) {
					// account exists, show password field
					if (response.data.record[0] === "Account exists, proceed to activation screen") {
						self.user = response.data.record[1];
						$('#email-exists-error').show();
					} else {
						$('#email-exists-error').hide();
					}
				}
			});
		}

		function isPasswordValid(password_arg) {
			var password = password_arg || $('#password').val();

			var returnValue = true;
			var passLength = $('.password-length');
			var passNumber = $('.password-contains-number');
			var passLowercase = $('.password-contains-lowercase');
			var passUppercase = $('.password-contains-uppercase');

			// validate the length
			if (password.length >= 8 && password.length <= 20) {
				passLength.addClass('passed');
			} else {
				passLength.removeClass('passed');
				returnValue = false;
			}

			// validate number
			if (password.match(/[0-9]/)) {
				passNumber.addClass('passed');
			} else {
				passNumber.removeClass('passed');
				returnValue = false;
			}

			// validate lowercase letter
			if (password.match(/[a-z]/)) {
				passLowercase.addClass('passed');
			} else {
				returnValue = false;
				passLowercase.removeClass('passed');
			}

			// validate uppercase letter
			if (password.match(/[A-Z]/)) {
				passUppercase.addClass('passed');
			} else {
				returnValue = false;
				passUppercase.removeClass('passed');
			}

			return returnValue;
		}

		function closeTravelersOverlay() {
			$('.modal-overlay').addClass('hidden');
		}

		// function openTravelersOverlay() {
		//     $('.modal-overlay').removeClass('hidden');
		// }

		var statesList = [];
		function getStates() {
			$.ajax({
				url: '/ajax/states',
				type: 'get',
				dataType: 'json',
				success: function success(response) {
					for (var i = response.data.record.length - 1; i >= 0; i--) {
						if (response.data.record[i].name && response.data.record[i].code && response.data.record[i].status == '1') {
							if (!statesList[response.data.record[i].country]) {
								statesList[response.data.record[i].country] = [];
							}
							if (_typeof(response.data.record[i].name) === 'object') {
								response.data.record[i].name = response.data.record[i].code;
							}
							statesList[response.data.record[i].country].push({ 'abbreviation': response.data.record[i].code, 'name': response.data.record[i].name });
						}
					}

					$('#country').trigger('change');
				}
			});
		}

		function changeStates(event) {
			var target = event.target;
			var selectedCountry = $(event.currentTarget).children(':selected').text();
			var unsortedStates;
			var sortedStates;

			if (statesList[selectedCountry]) {
				unsortedStates = statesList[selectedCountry];
				sortedStates = Array.apply(null, unsortedStates).sort(function (a, b) {
					return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
				});
			} else {
				sortedStates = [{ abbreviation: 'other', name: 'Other' }];
			}

			var options = $.map(sortedStates, function (option) {
				var text, value, ret;
				if (!option.name && !option.abbreviation) {
					return false;
				} else {
					// since our data isn't all that great, use one to cover the gaps in the other
					value = _typeof(option.abbreviation) !== 'object' ? option.abbreviation : option.name;
					text = _typeof(option.name) !== 'object' ? option.name : option.abbreviation;

					ret = '<option value="' + value + '"' + ($('#state').attr('data-value') === value ? ' selected' : '') + '>' + text + '</option>';
					return ret;
				}
			});
			options.splice(0, 0, '<option value disabled selected>' + (selectedCountry === 'Canada' ? 'Select a Province' : 'Select a State') + '</option>');

			$('#state').html(options);

			// Update country code for phone based on country, then revalidate
			$('#countrycode').val(target.options[target.selectedIndex].getAttribute('data-phonecode')).parsley().validate();
		}

		function handleSubmit(formSelector) {
			console.log('handleSubmit');
			return function handleSubmitInner(e) {
				e.preventDefault();

				var profileData = $(formSelector).serializeArray().reduce(function (sum, pair) {
					sum[pair.name] = pair.value;
					return sum;
				}, {});
				$('.loader-wrapper').addClass('visible');
				$.ajax({
					url: '/ajax/update-guest',
					type: 'POST',
					data: profileData,
					dataType: 'json',
					success: function success(response) {
						// console.log('received', response);

						if (response.data.errors) {
							$('.loader-wrapper').removeClass('visible');
							$(formSelector + ' .form-errors').fadeIn().html(response.data.errors.record).delay(5000).fadeOut();
							window.trackFormError(response.data.errors.record);
							return false;
						} else if (response.data.error) {
							$('.loader-wrapper').removeClass('visible');
							$(formSelector + ' .form-errors').fadeIn().html(response.data.error.record).delay(5000).fadeOut();
							window.trackFormError(response.data.error.record);
							return false;
						} else {
							// if (Cookies.get('carlson_remember') === 'true') {
							// localStorage.setItem('cacheData', JSON.stringify(response.data.record.record));
							// } else {
							var resultMessage = 'success-profile-updated';
							if (formSelector === '#edit-password') {
								resultMessage = 'success-password-change';
							}
							// }
							// return true;
							window.location.href = KEY_PAGES['profile'][LANG] + '?result=' + resultMessage;
						}
					}
				});
				return false;
			};
		}
	}
};

/***/ }),

/***/ 355:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var referrer = __webpack_require__(67);
var queryString = __webpack_require__(60);

module.exports = function handleCCForgotPasswordPageReady() {

    referrer.popLastPage();

    // if it's the actual reset form, with new password fields
    if (queryString.token && queryString.webuid) {
        // console.log('Initializing in reset mode');
        $('.show-pass').click(function () {
            if ($(this).next().prop('type') == 'password') {
                $(this).text($(this).data('hide'));
                $(this).next().prop('type', 'text');
            } else {
                $(this).text($(this).data('show'));
                $(this).next().prop('type', 'password');
            }
        });

        $('.password-reset-form').submit(function (e) {
            e.preventDefault();
            if ($('.password-reset-form').parsley().validate()) {
                submitRequest(e);
            }
            // don't actually submit
            return;
        });
    }

    // if it's the request form, with only the email address
    else {
            // console.log('Initializing in forgot mode');
            $('#reset-password').parsley();

            $(".pop").on("click", function (e) {
                e.preventDefault();
                submitRequest(e);
            });
        }

    // Submit update password request
    function submitRequest() {

        var postData;

        // if it's the actual reset form, with new password fields
        if (queryString.token && queryString.webuid) {

            // console.log('Submitting Form in reset mode');

            // Get userid value from form
            postData = {
                'email': $('input[name=email]').val(),
                'password': $('input[name=password]').val(),
                'webuid': queryString.webuid,
                'token': queryString.token
            };

            $.ajax({
                url: '/ajax/update-password',
                type: 'POST',
                data: postData,
                dataType: 'json',
                success: function success(response) {
                    if (response.data.error) {
                        $('.form-errors').fadeIn().html(response.data.error).delay(5000).fadeOut();
                        window.trackFormError(response.data.error);
                        return false;
                    } else {
                        $('.signup-form').parent().fadeOut(500);
                        $('.reset-success').delay(500).fadeIn();
                    }
                }
            });
        }

        // if it's the request form, with only the email address
        else {
                // console.log('Submitting Form in forgot mode');
                // Get userid value from form
                postData = {
                    'email': $('input[name=userid]').val()
                };

                $.ajax({
                    url: '/ajax/password-request',
                    type: 'POST',
                    data: postData,
                    dataType: 'json',
                    success: function success(response) {
                        // console.log('Response:', response, '/ajax/password-request?'+$.param(postData));
                        if (response.data.error) {
                            $('#userid-error').fadeIn().text(response.data.error).delay(5000).fadeOut();
                            window.trackFormError(response.data.error);
                            return false;
                        } else {
                            $('.forgot-form').fadeOut(500);
                            $('.forgot-success').delay(500).fadeIn();
                        }
                    }
                });
            }
    }
};

/***/ }),

/***/ 356:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var moment = __webpack_require__(0);
var Flickity = __webpack_require__(81);

module.exports = function handleCCLandingPageReady() {
    $('.primarynav li:nth-child(5)').addClass('active');
    // close navigation when you click login button
    $('.primarynav-login a').on('click', function () {
        $('.menubutton').trigger('click');
    });
    $('html, body').addClass('no-scroll');
    enhancePage();

    function enhancePage() {
        // Format date using moment
        $.each($('.offer-expiry'), function () {
            $(this).text(moment($(this).text()).format('LL'));
        });

        var flkty = document.querySelector('.slideshow-container');
        new Flickity(flkty, {
            // options
            cellAlign: 'left',
            contain: true,
            prevNextButtons: false,
            pageDots: false,
            setGallerySize: false,
            watchCSS: true
        });

        $('html, body').removeClass('no-scroll');
    }
};

/***/ }),

/***/ 357:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);

module.exports = function handleCCMemberBenefitsPageReady() {
    $(document).ready(function () {
        $('.level-header').click(toggleSection);
    });

    function toggleSection(e) {
        var contents = $(e.target).parent().find('.level-benefits');

        if (contents.css('visibility') === 'hidden') {
            contents.css('visibility', 'visible').css('opacity', 1).css('max-height', '100%');
        } else {
            contents.css('visibility', 'hidden').css('opacity', 0).css('max-height', 0);
        }
    }
};

/***/ }),

/***/ 358:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var mobileNav = __webpack_require__(47);

module.exports = function handleCCPersonalInformationPageReady() {
    $('.statement-activity-item:lt(5)').addClass('visible-item');

    // Activate side nav tab (static for now)
    $(".account-nav li:nth-child(3) a").addClass("active");
    mobileNav();
};

/***/ }),

/***/ 359:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var mobileNav = __webpack_require__(47);

module.exports = function handleCCPreferencesPageReady() {
    var utag = window.utag;
    var form = $('#edit-user-preferences');
    var airlinesSection = $('.user-miles-info');
    var milesRadioButton = $('#autoConvertToMiles');
    var earningsRadioButtons = $('#autoConvertToMiles-points, #autoConvertToMiles');

    form.submit(handleSubmit);
    earningsRadioButtons.click(toggleAirlinesSection);

    toggleAirlinesSection();
    // Activate side nav tab (static for now)
    $(".account-nav li:nth-child(4) a").addClass("active");
    mobileNav();

    function handleSubmit(e) {
        e.preventDefault();

        var optedIn = false;
        if ($('input#emailupdates').is(':checked')) {
            optedIn = true;
        }

        var formData = form.serializeArray().reduce(function (sum, pair) {
            sum[pair.name] = pair.value;
            return sum;
        }, {});

        console.log('form data', formData);

        return $.ajax({
            url: '/ajax/update-guest',
            type: 'POST',
            data: formData,
            dataType: 'json',
            success: function success(response) {
                console.log('got response', response);
                var prefCode = $('input[name=language]').val().toLowerCase();
                $.post("/ajax/language-code?code=" + prefCode, function () {
                    // request current page in the new language
                    var currLang = '/' + $('.selected-language').data('code') + '/',
                        url = window.location.toString();
                    if (window.location.pathname == '/' + $('.selected-language').data('code')) {
                        window.location = '/' + prefCode;
                    } else {
                        window.location = url.replace(currLang, '/' + prefCode + '/');
                    }
                });
                //window.location.href = '/'+LANG+'/club-carlson/my-account/preferences';

                if (optedIn == true) {
                    utag.link({
                        'eventTracking.eventName': 'Club Carlson Preferences Form Submission',
                        'user.userInfo.emailOptIn': '1'
                    });
                } else {
                    utag.link({
                        'eventTracking.eventName': 'Club Carlson Preferences Form Submission',
                        'user.userInfo.emailOptIn': '0'
                    });
                }
            }
        });
    }

    function toggleAirlinesSection() {
        if (milesRadioButton.is(':checked')) {
            airlinesSection.show();
        } else {
            airlinesSection.hide();
        }
    }
};

/***/ }),

/***/ 360:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var queryString = __webpack_require__(60);

module.exports = function handleCCResetConfirmationPageReady() {
    getEmailParam();

    function getEmailParam() {
        var email = queryString.email;
        if (email) {
            $('#user-id').text(decodeURIComponent(email));
        }
    }
};

/***/ }),

/***/ 361:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var moment = __webpack_require__(0);

module.exports = function handleECertsPageReady() {
    $(".ecert-lookup-button").click(function (e) {
        e.preventDefault();
        ecertLookup();
    });

    function ecertLookup() {
        var ecertCode = $('#ecert-lookup-field').val();

        $.ajax({
            url: '/ajax/get-ecert-info?ecertCode=' + ecertCode,
            type: 'GET',
            dataType: 'json',
            success: function success(response) {
                if (response.data.error) {
                    $('.field-errors').html(response.data.error).addClass('show-error');
                    $('.account-ecert.lookup-ecert').removeClass('show-ecert');
                    window.trackFormError(response.data.error);
                } else {
                    $('.field-errors').removeClass('show-error').html('');
                    var ecert = response.data;
                    ecert.endDate = moment(ecert.endDate).format('D MMM, YYYY');
                    $("#ecoName").text(ecert.ecoName);
                    $("#ecertCode").text("Code: " + ecert.ecoName);
                    $("#ecoPercent").text("Value: " + ecert.ecoName + "% Off");
                    $("#endDate").text("Expiration: " + ecert.ecoName);
                    $('.account-ecert.lookup-ecert').addClass('show-ecert');
                }
            }
        });
    }
};

/***/ }),

/***/ 362:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* jshint esversion: 6 */
var $ = __webpack_require__(2);
var mobileNav = __webpack_require__(47);
var Flickity = __webpack_require__(81);

module.exports = function handleMyAccountPageReady() {
    var utag = window.utag;
    var Foundation = window.Foundation;

    $(".primarynav li:nth-child(5)").addClass("active");
    $('.account-nav li:nth-child(1)').addClass('active');

    // setTimeout seems to do the trick when using XML data with page variables
    setTimeout(this.getSnippets, 500);
    // TODO: read user certs, convert function
    // getEcertsForProfile();
    tabletOrientation();
    if (Foundation.MediaQuery.current == 'small' || Foundation.MediaQuery.current == 'medium') {
        $('.dashboard').addClass('nav-visible');
    }

    var url = window.location.href;
    var param = getParameterByName('showNavForMobile', url);
    if (param == '0') {
        mobileNav();
    }

    $("a.reservation-cancel-link").on("keypress", function (ev) {
        if (ev.which === 13) {
            $(this).click();
        }
    });

    function tabletOrientation() {
        var windowWidth = $(window).width();

        window.addEventListener("resize", function () {
            // need to test window width to prevent resize event from firing on scroll
            if ($(window).width() != windowWidth) {
                windowWidth = $(window).width();
                if (Foundation.MediaQuery.atLeast('large')) {
                    $('.dashboard-account, .dashboard-sidebar').removeClass('slide-left');
                } else {
                    $('.dashboard-account, .dashboard-sidebar').addClass('slide-left');
                    if ($('.slideshow-container').length) {
                        specialOfferSlider();
                    }
                }
            }
        }, false);
    }

    function specialOfferSlider() {
        var flkty = document.querySelector('.slideshow-container');
        new Flickity(flkty, {
            // options
            cellAlign: 'left',
            contain: true,
            prevNextButtons: false,
            pageDots: false,
            setGallerySize: false,
            watchCSS: true
        });
    }

    // Get CMS snippets from page SNIPPETS variable
    // This may need to be tweaked as sometimes content from page variables comes back as undefined
    function getSnippets() {
        var snippets = window.SNIPPETS;

        for (var i = 0; i < snippets.length; i++) {
            if (snippets[i].code == 'click-to-chat') {
                this.snippet = snippets[i].snippet;
            }
        }
    }

    function getParameterByName(name, href) {
        var replacedName = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regexS = "[\\?&]" + replacedName + "=([^&#]*)";
        var regex = new RegExp(regexS);
        var results = regex.exec(href);
        if (results == null) return "";else return decodeURIComponent(results[1].replace(/\+/g, " "));
    }

    function cancelReservation() {
        var params = {
            reservation: $('#cancel-reservation').data("conf")
        };

        // if (this.sharedState.config.debug) { this.ajaxUrl('/ajax/cancel-reservation',params); }
        $.get('/ajax/cancel-reservation', params).done(function (data) {
            console.log(data);
            if (data.data.cancellation) {
                console.log("confirm cancel", data.data);
                toggleCancelModal();
                // TODO: Redirect to confirmation of cancel
            } else if (data.data.error) {
                // TODO: Show visual error instead of log
                console.log("error", data.data.error['@attributes']['description']);
            } else if (data.data.errors) {
                // TODO: Show visual error instead of log
                console.log("error", data.data.errors.record);
            }
        });
    }

    function toggleCancelModal(conf) {
        if (conf) {
            $('#cancel-reservation').data("conf", conf);
        }

        if ($('#cancel-reservation').hasClass('is-open')) {
            $('#cancel-reservation').data("conf", null);
            $('#cancel-reservation').removeClass('is-open');
            $('.modal-overlay').remove();
            setTimeout(function () {
                $(".guest-info-button a.button.primary").attr("tabindex", 0);
                $(".reservation-total-buttons  a.button.secondary").attr("tabindex", 0);
                $("#cancel-reservation").focus(function () {});
            }, 200);
        } else {
            $(".bookingview-full-body").show();
            $('#cancel-reservation').addClass('is-open');
            $('body').append('<div class="modal-overlay"></div>');
            utag.link({
                'eventTracking.clickElement': 'Cancel Reservation'
            });
            setTimeout(function () {
                $(".guest-info-button a.button.primary").attr("tabindex", -1);
                $(".reservation-total-buttons  a.button.secondary").attr("tabindex", -1);
                $("button.close-btn").focus(function () {});
            }, 200);
        }
    }

    $(".cancelres-buttons .primary").on("keypress", function (ev) {
        if (ev.which === 13) {
            cancelReservation();
        }

        console.log('clicked');
    });
};

/***/ }),

/***/ 363:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var mobileNav = __webpack_require__(47);
var queryString = __webpack_require__(60);

/* globals moment USERINFO PAGEINFO BRAND */

module.exports = function handleReservationsPageReady() {
  var utag = window.utag;

  $('.reservations-card.previous-card .previous-add-cart').each(function () {
    $(this).on('click', function () {
      prevRez();
    });
  });

  $(".primarynav li:nth-child(5)").addClass("active");

  // Activate side nav tab (static for now)
  $(".account-nav li:nth-child(2) a").addClass("active");
  mobileNav();

  //Format check in and checkout dates
  $('.reservation-detail-overlay').each(function () {
    $(this).find('#checkInDate').append(moment($(this).find('#checkIn').val(), 'HH:mm').format('h:mm A') + '-' + moment($(this).find('#startDate').val(), 'MM/DD/YYYY').format('ddd, MMM D, YYYY'));
    $(this).find('#CheckoutDate').append(moment($(this).find('#checkOut').val(), 'HH:mm').format('h:mm A') + '-' + moment($(this).find('#endDate').val(), 'MM/DD/YYYY').format('ddd, MMM D, YYYY'));
  });

  if (queryString.conf) {
    var conf = queryString.conf;

    if ($("input[value=" + conf + "]").attr("data-type") == "PAST") {
      getPast();
      $("#reservation-detail-" + conf).css({ "width": "100%", "display": "block" });
      $("#reservations-upcoming-tab").css("display", "none");
      $("#reservations-previous-tab").css("display", "none");
      $(".dashboard-mobile-nav-header").css("display", "none");
      $(".reservations-info-header").css("display", "none");
    } else {
      getFuture();
      $("#reservation-detail-" + conf).css({ "width": "100%", "display": "block" });
      $("#reservations-upcoming-tab").css("display", "none");
      $("#reservations-previous-tab").css("display", "none");
      $(".dashboard-mobile-nav-header").css("display", "none");
      $(".reservations-info-header").css("display", "none");
    }
  } else {
    if (queryString.type == 'PAST') {
      getPast();
    } else {
      landReservations();
    }
  }

  if ($(".reservations-card")) {
    $(".reservations-card").on("click", function () {
      var conf = $(this).find("#confnum").attr("value");
      $("#reservation-detail-" + conf).css({ "width": "100%", "display": "block" });
      $("#reservations-upcoming-tab").css("display", "none");
      $("#reservations-previous-tab").css("display", "none");
      $(".dashboard-mobile-nav-header").css("display", "none");
      $(".reservations-info-header").css("display", "none");
      trackReservationDetail();
    });
    $(".modal-close").on("click", function () {
      $(this).parent().parent().css({ "width": "0%", "display": "none" });
      $("#reservations-upcoming-tab").css("display", "block");
      $("#reservations-previous-tab").css("display", "block");
      $(".dashboard-mobile-nav-header").css("display", "block");
      $(".reservations-info-header").css("display", "block");
    });
  }

  $(".future-tab").on("click", function () {
    getFuture();
  });

  $(".past-tab").on("click", function () {
    getPast();
  });

  $(".reservation-cancel-link").on("click", function () {
    toggleCancelModal($(this).data('conf'));
  });

  $(".cancelres-buttons .primary").on("keypress", function (ev) {
    if (ev.which === 13) {
      cancelReservation();
    }
  });
};

window.landReservations = landReservations;
function landReservations() {
  if (typeof window.utag !== 'undefined') {
    window.utag.view({
      'page.pageInfo.pageName': 'upcomingReservationsLanding',
      'page.pageInfo.primaryCategory': 'Loyalty',
      'page.pageInfo.pagePath': PAGEINFO.pagePath,
      'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
      'page.pageInfo.referringURL': PAGEINFO.referringURL,
      'page.pageInfo.language': PAGEINFO.language,
      'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
      'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
      'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
      'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
      'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
      'page.pageInfo.timeZone': PAGEINFO.timezone,
      'page.pageInfo.brand': BRAND.slug,
      'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
      'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
      'page.pageInfo.bvCode': PAGEINFO.bvCode,
      'page.pageInfo.isWebview': PAGEINFO.isWebView,
      'user.userInfo.userID': USERINFO.userId,
      'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier,
      'user.userInfo.authentication': '0'
    });
  }
  $(".past-reservation-content").css("display", "none");
  $(".future-reservation-content").css("display", "block");
  $(".future-tab").addClass('active-tab-nav');
  $(".past-tab").removeClass('active-tab-nav');
}

window.getFuture = getFuture;
function getFuture() {
  if (typeof window.utag !== 'undefined') {
    window.utag.view({
      'page.pageInfo.pageName': 'upcomingReservationsTab',
      'page.pageInfo.primaryCategory': 'Loyalty',
      'page.pageInfo.pagePath': PAGEINFO.pagePath,
      'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
      'page.pageInfo.referringURL': PAGEINFO.referringURL,
      'page.pageInfo.language': PAGEINFO.language,
      'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
      'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
      'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
      'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
      'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
      'page.pageInfo.timeZone': PAGEINFO.timezone,
      'page.pageInfo.brand': BRAND.slug,
      'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
      'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
      'page.pageInfo.bvCode': PAGEINFO.bvCode,
      'page.pageInfo.isWebview': PAGEINFO.isWebView,
      'user.userInfo.userID': USERINFO.userId,
      'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier,
      'user.userInfo.authentication': '0'
    });
  }
  $(".past-reservation-content").css("display", "none");
  $(".future-reservation-content").css("display", "block");
  $(".future-tab").addClass('active-tab-nav');
  $(".past-tab").removeClass('active-tab-nav');
}

window.getPast = getPast;
function getPast() {
  if (typeof window.utag !== 'undefined') {
    window.utag.view({
      'page.pageInfo.pageName': 'previousReservationsTab',
      'page.pageInfo.primaryCategory': 'Loyalty',
      'page.pageInfo.pagePath': PAGEINFO.pagePath,
      'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
      'page.pageInfo.referringURL': PAGEINFO.referringURL,
      'page.pageInfo.language': PAGEINFO.language,
      'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
      'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
      'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
      'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
      'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
      'page.pageInfo.timeZone': PAGEINFO.timezone,
      'page.pageInfo.brand': BRAND.slug,
      'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
      'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
      'page.pageInfo.bvCode': PAGEINFO.bvCode,
      'page.pageInfo.isWebview': PAGEINFO.isWebView,
      'user.userInfo.userID': USERINFO.userId,
      'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier,
      'user.userInfo.authentication': '0'
    });
  }
  $(".future-tab").removeClass('active-tab-nav');
  $(".past-tab").addClass('active-tab-nav');
  $(".future-reservation-content").css("display", "none");
  $(".past-reservation-content").css("display", "block");
}

window.toggleCancelModal = toggleCancelModal;
function toggleCancelModal(conf) {
  var cancelPolicy = '';
  if (conf) {
    $('#cancel-reservation').data("conf", conf);
    cancelPolicy = $('#reservation-detail-' + conf + ' .reservations-upcoming-policy').html();
  }

  if ($('#cancel-reservation').hasClass('is-open')) {
    $('#cancel-reservation').data("conf", null);
    $('#cancel-reservation').removeClass('is-open');
    $('.modal-overlay').remove();
    $('#cancel-reservation .reservations-cancel-policy').html('');

    if (!conf) {
      window.utag.view({
        'eventTracking.eventName': 'Room Cancellation Not Completed',
        'page.pageInfo.pageName': 'upcomingReservationsTab',
        'page.pageInfo.pagePath': PAGEINFO.pagePath,
        'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
        'page.pageInfo.referringURL': PAGEINFO.referringURL,
        'page.pageInfo.language': PAGEINFO.language,
        'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
        'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
        'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
        'page.pageInfo.primaryCategory': 'Loyalty',
        'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
        'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
        'page.pageInfo.timeZone': PAGEINFO.timezone,
        'page.pageInfo.brand': BRAND.slug,
        'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
        'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
        'page.pageInfo.bvCode': PAGEINFO.bvCode,
        'page.pageInfo.isWebview': PAGEINFO.isWebView,
        'user.userInfo.userID': USERINFO.userId,
        'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier
      });
    }

    setTimeout(function () {
      $(".guest-info-button a.button.primary").attr("tabindex", 0);
      $(".reservation-total-buttons  a.button.secondary").attr("tabindex", 0);
      $("#cancel-reservation").focus(function () {});
    }, 200);
  } else {
    $('#cancel-reservation .reservations-cancel-policy').html(cancelPolicy);
    $(".bookingview-full-body").show();
    $('#cancel-reservation').addClass('is-open');
    $('body').append('<div class="modal-overlay"></div>');

    //Fire utag.view
    window.utag.view({
      'eventTracking.eventName': 'Cancel Reservation',
      'reservationCancellation.reservationNumber': conf,
      'page.pageInfo.pageName': 'cancelReservationYesOrNoOverlay',
      'page.pageInfo.primaryCategory': 'Loyalty',
      'page.pageInfo.pagePath': PAGEINFO.pagePath,
      'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
      'page.pageInfo.referringURL': PAGEINFO.referringURL,
      'page.pageInfo.language': PAGEINFO.language,
      'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
      'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
      'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
      'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
      'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
      'page.pageInfo.timeZone': PAGEINFO.timezone,
      'page.pageInfo.brand': BRAND.slug,
      'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
      'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
      'page.pageInfo.bvCode': PAGEINFO.bvCode,
      'page.pageInfo.isWebview': PAGEINFO.isWebView,
      'user.userInfo.userID': USERINFO.userId,
      'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier
    });

    setTimeout(function () {
      $(".guest-info-button a.button.primary").attr("tabindex", -1);
      $(".reservation-total-buttons  a.button.secondary").attr("tabindex", -1);
      $("button.close-btn").focus(function () {});
    }, 200);
  }
}

window.cancelReservation = cancelReservation;
function cancelReservation() {
  var reservationNumber = $('#cancel-reservation').data("conf");
  var totalExclusive = $("#total-" + reservationNumber).val();

  var params = {
    reservation: reservationNumber
  };

  $.get('/ajax/cancel-reservation', params).done(function (data) {
    console.log(data);
    if (data.data.cancellation) {
      console.log("confirm cancel", data.data);
      toggleCancelModal(data.data.cancellation);

      //Fire utag.view
      window.utag.view({
        'eventTracking.eventName': 'Confirmed Room Cancellation',
        'page.pageInfo.pageName': PAGEINFO.pageName,
        'page.pageInfo.primaryCategory': 'Loyalty',
        'page.pageInfo.pagePath': PAGEINFO.pagePath,
        'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
        'page.pageInfo.referringURL': PAGEINFO.referringURL,
        'page.pageInfo.language': PAGEINFO.language,
        'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
        'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
        'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
        'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
        'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
        'page.pageInfo.timeZone': PAGEINFO.timezone,
        'page.pageInfo.brand': BRAND.slug,
        'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
        'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
        'page.pageInfo.bvCode': PAGEINFO.bvCode,
        'page.pageInfo.isWebview': PAGEINFO.isWebView,
        'user.userInfo.userID': USERINFO.userId,
        'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier
      });

      window.location.href = './reservations/cancel?reservationNum=' + reservationNumber + '&cancelConf=' + data.data.cancellation + '&total=' + totalExclusive;

      // TODO: Redirect to confirmation of cancel
    } else if (data.data.error) {
      toggleCancelModal();
      // TODO: Show visual error instead of log
      console.log("error", data.data.error['@attributes']['description']);
      window.errorMessage(data.data.error['@attributes']['description']);
    } else if (data.data.errors) {
      toggleCancelModal();
      // TODO: Show visual error instead of log
      console.log("error", data.data.errors.record);
      window.errorMessage(data.data.errors.record);
    }
  });
}

window.closeCancelOverlay = closeCancelOverlay;
function closeCancelOverlay() {
  toggleCancelModal();
}

window.cancelOverlayNoClick = cancelOverlayNoClick;
function cancelOverlayNoClick() {
  toggleCancelModal();
}

window.trackReservationDetail = trackReservationDetail;
function trackReservationDetail() {
  if (typeof window.utag !== 'undefined') {
    if ($(this).hasClass('upcoming-card')) {
      window.utag.view({
        'page.pageInfo.pageName': 'virtualUpcomingReservationDetails',
        'page.pageInfo.pagePath': PAGEINFO.pagePath,
        'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
        'page.pageInfo.referringURL': PAGEINFO.referringURL,
        'page.pageInfo.language': PAGEINFO.language,
        'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
        'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
        'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
        'page.pageInfo.primaryCategory': 'Loyalty',
        'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
        'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
        'page.pageInfo.timeZone': PAGEINFO.timezone,
        'page.pageInfo.brand': BRAND.slug,
        'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
        'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
        'page.pageInfo.bvCode': PAGEINFO.bvCode,
        'page.pageInfo.isWebview': PAGEINFO.isWebView,
        'user.userInfo.userID': USERINFO.userId,
        'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier
      });
    } else {
      window.utag.view({
        'page.pageInfo.pageName': 'virtualPreviousReservationDetails',
        'page.pageInfo.pagePath': PAGEINFO.pagePath,
        'page.pageInfo.destinationURL': PAGEINFO.destinationURL,
        'page.pageInfo.referringURL': PAGEINFO.referringURL,
        'page.pageInfo.language': PAGEINFO.language,
        'page.pageInfo.geoRegion': PAGEINFO.geoRegion,
        'page.pageInfo.systemEnv': PAGEINFO.systemEnv,
        'page.pageInfo.effectiveDate': PAGEINFO.effectiveDate,
        'page.pageInfo.primaryCategory': 'Loyalty',
        'page.pageInfo.dayOfWeek': PAGEINFO.dayOfWeek,
        'page.pageInfo.timeOfDay': PAGEINFO.timeOfDay,
        'page.pageInfo.timeZone': PAGEINFO.timezone,
        'page.pageInfo.brand': BRAND.slug,
        'page.pageInfo.facilitatorID': PAGEINFO.facilitatorID,
        'page.pageInfo.currencyCode': PAGEINFO.currencyCode,
        'page.pageInfo.bvCode': PAGEINFO.bvCode,
        'page.pageInfo.isWebview': PAGEINFO.isWebView,
        'user.userInfo.userID': USERINFO.userId,
        'user.userInfo.loyaltyTier': USERINFO.userLoyaltyTier
      });
    }
  }
}

window.prevRez = prevRez;
function prevRez() {
  window.utag.link({
    'eventTracking.clickElement': 'Book Hotel Again'
  });
}

/***/ }),

/***/ 364:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var mobileNav = __webpack_require__(47);
var moment = __webpack_require__(0);

module.exports = function handleStatementPageReady() {
  $('.statement-activity-item:lt(5)').addClass('visible-item');

  // Activate side nav tab (static for now)
  $(".account-nav li:nth-child(1) a").addClass("active");
  mobileNav();

  $(".ecert-lookup-button").click(function (e) {
    e.preventDefault();
    ecertLookup();
  });

  function viewMore() {
    var visibleStatements = parseInt($('#statementCount').val(), 10);
    var inrementor = 5;
    visibleStatements += inrementor;

    var activityItems = $('.statement-activity-item:lt(' + visibleStatements + ')');
    activityItems.addClass('visible-item');
    $('#statementCount').val(visibleStatements);

    if (visibleStatements > activityItems.length) {
      $('button.view-more').fadeOut(250);
    }
  }

  $('.view-more').click(function () {
    viewMore();
  });

  // Close member statement modal
  function closeStatement() {
    $('.member-statement-modal').removeClass('active');
    $('body, html').removeClass('no-scroll');
    window.location = '/' + window.LANG + '/club-carlson/my-account';
  }

  $('.modal-close-statement').click(function () {
    closeStatement();
  });

  function ecertLookup() {
    var ecertCode = $('#ecert-lookup-field').val();

    $.ajax({
      url: '/ajax/get-ecert-info?ecertCode=' + ecertCode,
      type: 'GET',
      dataType: 'json',
      success: function success(response) {
        if (response.data.error) {
          $('.field-errors').html(response.data.error).addClass('show-error');
          $('.account-ecert.lookup-ecert').removeClass('show-ecert');
          window.trackFormError(response.data.error);
        } else {
          $('.field-errors').removeClass('show-error').html('');
          var ecert = response.data;
          ecert.endDate = moment(ecert.endDate).format('D MMM, YYYY');
          $("#ecoName").text(ecert.ecoName);
          $("#ecertCode").text("Code: " + ecert.ecoName);
          $("#ecoPercent").text("Value: " + ecert.ecoName + "% Off");
          $("#endDate").text("Expiration: " + ecert.ecoName);
          $('.account-ecert.lookup-ecert').addClass('show-ecert');
        }
      }
    });
  }
};

/***/ }),

/***/ 365:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var mobileNav = __webpack_require__(47);

module.exports = function handleCCCancelReservationPageReady() {

	var reservationConfirmation = $('#reservationNumber').val();
	var cancellationNumber = $('#cancellationNumber').val();

	var email = $('#email').val();
	mobileNav();

	$('.card').addClass("_3c");

	var i = 0;
	$(".card").each(function () {
		if (i >= 3) {
			$(this).addClass("hide");
		}
		i++;
	});

	$("#viewAllOffers").on("click", function () {
		showAllOffers();
	});

	$(".account-info").html($(".account-info").html().replace("${reservationnumber}", reservationConfirmation));
	$(".account-info").html($(".account-info").html().replace("${cancelnumber}", cancellationNumber));
	$(".account-info").html($(".account-info").html().replace("${email}", email));

	function showAllOffers() {
		$(".card").each(function () {
			$(this).removeClass("hide");
		});
		$("#viewAllOffers").hide();
	}
};

/***/ }),

/***/ 47:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $ = __webpack_require__(2);
var Foundation = window.Foundation; //TODO: Ensure NPM has the same version of Foundation as is being included in the header/footer of the site so we can replace this with require()

module.exports = mobileNav;

function mobileNav() {
    if (Foundation.MediaQuery.current == 'small' || Foundation.MediaQuery.current == 'medium') {
        $('.dashboard-account, .dashboard-sidebar').addClass('slide-left');
        $('.dashboard').removeClass('nav-visible');
    }
    // View nav when back arrow is clicked
    $('label[for="dashboard-nav-trigger"]').on('click', function () {
        if (Foundation.MediaQuery.current == 'small' || Foundation.MediaQuery.current == 'medium') {
            $('.dashboard-account, .dashboard-sidebar').removeClass('slide-left');
            $('.dashboard').addClass('nav-visible');
        }
    });
}

/***/ }),

/***/ 48:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * EvEmitter v1.1.0
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */

(function (global, factory) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, window */
  if (true) {
    // AMD - RequireJS
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }
})(typeof window != 'undefined' ? window : undefined, function () {

  "use strict";

  function EvEmitter() {}

  var proto = EvEmitter.prototype;

  proto.on = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    }
    // set events hash
    var events = this._events = this._events || {};
    // set listeners array
    var listeners = events[eventName] = events[eventName] || [];
    // only add once
    if (listeners.indexOf(listener) == -1) {
      listeners.push(listener);
    }

    return this;
  };

  proto.once = function (eventName, listener) {
    if (!eventName || !listener) {
      return;
    }
    // add event
    this.on(eventName, listener);
    // set once flag
    // set onceEvents hash
    var onceEvents = this._onceEvents = this._onceEvents || {};
    // set onceListeners object
    var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
    // set flag
    onceListeners[listener] = true;

    return this;
  };

  proto.off = function (eventName, listener) {
    var listeners = this._events && this._events[eventName];
    if (!listeners || !listeners.length) {
      return;
    }
    var index = listeners.indexOf(listener);
    if (index != -1) {
      listeners.splice(index, 1);
    }

    return this;
  };

  proto.emitEvent = function (eventName, args) {
    var listeners = this._events && this._events[eventName];
    if (!listeners || !listeners.length) {
      return;
    }
    // copy over to avoid interference if .off() in listener
    listeners = listeners.slice(0);
    args = args || [];
    // once stuff
    var onceListeners = this._onceEvents && this._onceEvents[eventName];

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      var isOnce = onceListeners && onceListeners[listener];
      if (isOnce) {
        // remove listener
        // remove before trigger to prevent recursion
        this.off(eventName, listener);
        // unset once flag
        delete onceListeners[listener];
      }
      // trigger listener
      listener.apply(this, args);
    }

    return this;
  };

  proto.allOff = function () {
    delete this._events;
    delete this._onceEvents;
  };

  return EvEmitter;
});

/***/ }),

/***/ 68:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * getSize v2.0.2
 * measure size of elements
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, module: false, console: false */

(function (window, factory) {
  'use strict';

  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return factory();
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.getSize = factory();
  }
})(window, function factory() {
  'use strict';

  // -------------------------- helpers -------------------------- //

  // get a number from a string, not a percentage

  function getStyleSize(value) {
    var num = parseFloat(value);
    // not a percent like '100%', and a number
    var isValid = value.indexOf('%') == -1 && !isNaN(num);
    return isValid && num;
  }

  function noop() {}

  var logError = typeof console == 'undefined' ? noop : function (message) {
    console.error(message);
  };

  // -------------------------- measurements -------------------------- //

  var measurements = ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth', 'borderBottomWidth'];

  var measurementsLength = measurements.length;

  function getZeroSize() {
    var size = {
      width: 0,
      height: 0,
      innerWidth: 0,
      innerHeight: 0,
      outerWidth: 0,
      outerHeight: 0
    };
    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      size[measurement] = 0;
    }
    return size;
  }

  // -------------------------- getStyle -------------------------- //

  /**
   * getStyle, get style of element, check for Firefox bug
   * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
   */
  function getStyle(elem) {
    var style = getComputedStyle(elem);
    if (!style) {
      logError('Style returned ' + style + '. Are you running this code in a hidden iframe on Firefox? ' + 'See http://bit.ly/getsizebug1');
    }
    return style;
  }

  // -------------------------- setup -------------------------- //

  var isSetup = false;

  var isBoxSizeOuter;

  /**
   * setup
   * check isBoxSizerOuter
   * do on first getSize() rather than on page load for Firefox bug
   */
  function setup() {
    // setup once
    if (isSetup) {
      return;
    }
    isSetup = true;

    // -------------------------- box sizing -------------------------- //

    /**
     * WebKit measures the outer-width on style.width on border-box elems
     * IE & Firefox<29 measures the inner-width
     */
    var div = document.createElement('div');
    div.style.width = '200px';
    div.style.padding = '1px 2px 3px 4px';
    div.style.borderStyle = 'solid';
    div.style.borderWidth = '1px 2px 3px 4px';
    div.style.boxSizing = 'border-box';

    var body = document.body || document.documentElement;
    body.appendChild(div);
    var style = getStyle(div);

    getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize(style.width) == 200;
    body.removeChild(div);
  }

  // -------------------------- getSize -------------------------- //

  function getSize(elem) {
    setup();

    // use querySeletor if elem is string
    if (typeof elem == 'string') {
      elem = document.querySelector(elem);
    }

    // do not proceed on non-objects
    if (!elem || (typeof elem === 'undefined' ? 'undefined' : _typeof(elem)) != 'object' || !elem.nodeType) {
      return;
    }

    var style = getStyle(elem);

    // if hidden, everything is 0
    if (style.display == 'none') {
      return getZeroSize();
    }

    var size = {};
    size.width = elem.offsetWidth;
    size.height = elem.offsetHeight;

    var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

    // get all measurements
    for (var i = 0; i < measurementsLength; i++) {
      var measurement = measurements[i];
      var value = style[measurement];
      var num = parseFloat(value);
      // any 'auto', 'medium' value will be 0
      size[measurement] = !isNaN(num) ? num : 0;
    }

    var paddingWidth = size.paddingLeft + size.paddingRight;
    var paddingHeight = size.paddingTop + size.paddingBottom;
    var marginWidth = size.marginLeft + size.marginRight;
    var marginHeight = size.marginTop + size.marginBottom;
    var borderWidth = size.borderLeftWidth + size.borderRightWidth;
    var borderHeight = size.borderTopWidth + size.borderBottomWidth;

    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

    // overwrite width and height if we can get it from style
    var styleWidth = getStyleSize(style.width);
    if (styleWidth !== false) {
      size.width = styleWidth + (
      // add padding and border unless it's already including it
      isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
    }

    var styleHeight = getStyleSize(style.height);
    if (styleHeight !== false) {
      size.height = styleHeight + (
      // add padding and border unless it's already including it
      isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
    }

    size.innerWidth = size.width - (paddingWidth + borderWidth);
    size.innerHeight = size.height - (paddingHeight + borderHeight);

    size.outerWidth = size.width + marginWidth;
    size.outerHeight = size.height + marginHeight;

    return size;
  }

  return getSize;
});

/***/ }),

/***/ 69:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Unipointer v2.2.0
 * base class for doing one thing with pointer event
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

(function (window, factory) {
  // universal module definition
  /* jshint strict: false */ /*global define, module, require */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(48)], __WEBPACK_AMD_DEFINE_RESULT__ = function (EvEmitter) {
      return factory(window, EvEmitter);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('ev-emitter'));
  } else {
    // browser global
    window.Unipointer = factory(window, window.EvEmitter);
  }
})(window, function factory(window, EvEmitter) {

  'use strict';

  function noop() {}

  function Unipointer() {}

  // inherit EvEmitter
  var proto = Unipointer.prototype = Object.create(EvEmitter.prototype);

  proto.bindStartEvent = function (elem) {
    this._bindStartEvent(elem, true);
  };

  proto.unbindStartEvent = function (elem) {
    this._bindStartEvent(elem, false);
  };

  /**
   * works as unbinder, as you can ._bindStart( false ) to unbind
   * @param {Boolean} isBind - will unbind if falsey
   */
  proto._bindStartEvent = function (elem, isBind) {
    // munge isBind, default to true
    isBind = isBind === undefined ? true : !!isBind;
    var bindMethod = isBind ? 'addEventListener' : 'removeEventListener';

    if (window.PointerEvent) {
      // Pointer Events. Chrome 55, IE11, Edge 14
      elem[bindMethod]('pointerdown', this);
    } else {
      // listen for both, for devices like Chrome Pixel
      elem[bindMethod]('mousedown', this);
      elem[bindMethod]('touchstart', this);
    }
  };

  // trigger handler methods for events
  proto.handleEvent = function (event) {
    var method = 'on' + event.type;
    if (this[method]) {
      this[method](event);
    }
  };

  // returns the touch that we're keeping track of
  proto.getTouch = function (touches) {
    for (var i = 0; i < touches.length; i++) {
      var touch = touches[i];
      if (touch.identifier == this.pointerIdentifier) {
        return touch;
      }
    }
  };

  // ----- start event ----- //

  proto.onmousedown = function (event) {
    // dismiss clicks from right or middle buttons
    var button = event.button;
    if (button && button !== 0 && button !== 1) {
      return;
    }
    this._pointerDown(event, event);
  };

  proto.ontouchstart = function (event) {
    this._pointerDown(event, event.changedTouches[0]);
  };

  proto.onpointerdown = function (event) {
    this._pointerDown(event, event);
  };

  /**
   * pointer start
   * @param {Event} event
   * @param {Event or Touch} pointer
   */
  proto._pointerDown = function (event, pointer) {
    // dismiss other pointers
    if (this.isPointerDown) {
      return;
    }

    this.isPointerDown = true;
    // save pointer identifier to match up touch events
    this.pointerIdentifier = pointer.pointerId !== undefined ?
    // pointerId for pointer events, touch.indentifier for touch events
    pointer.pointerId : pointer.identifier;

    this.pointerDown(event, pointer);
  };

  proto.pointerDown = function (event, pointer) {
    this._bindPostStartEvents(event);
    this.emitEvent('pointerDown', [event, pointer]);
  };

  // hash of events to be bound after start event
  var postStartEvents = {
    mousedown: ['mousemove', 'mouseup'],
    touchstart: ['touchmove', 'touchend', 'touchcancel'],
    pointerdown: ['pointermove', 'pointerup', 'pointercancel']
  };

  proto._bindPostStartEvents = function (event) {
    if (!event) {
      return;
    }
    // get proper events to match start event
    var events = postStartEvents[event.type];
    // bind events to node
    events.forEach(function (eventName) {
      window.addEventListener(eventName, this);
    }, this);
    // save these arguments
    this._boundPointerEvents = events;
  };

  proto._unbindPostStartEvents = function () {
    // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)
    if (!this._boundPointerEvents) {
      return;
    }
    this._boundPointerEvents.forEach(function (eventName) {
      window.removeEventListener(eventName, this);
    }, this);

    delete this._boundPointerEvents;
  };

  // ----- move event ----- //

  proto.onmousemove = function (event) {
    this._pointerMove(event, event);
  };

  proto.onpointermove = function (event) {
    if (event.pointerId == this.pointerIdentifier) {
      this._pointerMove(event, event);
    }
  };

  proto.ontouchmove = function (event) {
    var touch = this.getTouch(event.changedTouches);
    if (touch) {
      this._pointerMove(event, touch);
    }
  };

  /**
   * pointer move
   * @param {Event} event
   * @param {Event or Touch} pointer
   * @private
   */
  proto._pointerMove = function (event, pointer) {
    this.pointerMove(event, pointer);
  };

  // public
  proto.pointerMove = function (event, pointer) {
    this.emitEvent('pointerMove', [event, pointer]);
  };

  // ----- end event ----- //


  proto.onmouseup = function (event) {
    this._pointerUp(event, event);
  };

  proto.onpointerup = function (event) {
    if (event.pointerId == this.pointerIdentifier) {
      this._pointerUp(event, event);
    }
  };

  proto.ontouchend = function (event) {
    var touch = this.getTouch(event.changedTouches);
    if (touch) {
      this._pointerUp(event, touch);
    }
  };

  /**
   * pointer up
   * @param {Event} event
   * @param {Event or Touch} pointer
   * @private
   */
  proto._pointerUp = function (event, pointer) {
    this._pointerDone();
    this.pointerUp(event, pointer);
  };

  // public
  proto.pointerUp = function (event, pointer) {
    this.emitEvent('pointerUp', [event, pointer]);
  };

  // ----- pointer done ----- //

  // triggered on pointer up & pointer cancel
  proto._pointerDone = function () {
    // reset properties
    this.isPointerDown = false;
    delete this.pointerIdentifier;
    // remove events
    this._unbindPostStartEvents();
    this.pointerDone();
  };

  proto.pointerDone = noop;

  // ----- pointer cancel ----- //

  proto.onpointercancel = function (event) {
    if (event.pointerId == this.pointerIdentifier) {
      this._pointerCancel(event, event);
    }
  };

  proto.ontouchcancel = function (event) {
    var touch = this.getTouch(event.changedTouches);
    if (touch) {
      this._pointerCancel(event, touch);
    }
  };

  /**
   * pointer cancel
   * @param {Event} event
   * @param {Event or Touch} pointer
   * @private
   */
  proto._pointerCancel = function (event, pointer) {
    this._pointerDone();
    this.pointerCancel(event, pointer);
  };

  // public
  proto.pointerCancel = function (event, pointer) {
    this.emitEvent('pointerCancel', [event, pointer]);
  };

  // -----  ----- //

  // utility function for getting x/y coords from event
  Unipointer.getPointerPoint = function (pointer) {
    return {
      x: pointer.pageX,
      y: pointer.pageY
    };
  };

  // -----  ----- //

  return Unipointer;
});

/***/ }),

/***/ 70:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Tap listener v2.0.0
 * listens to taps
 * MIT license
 */

/*jshint browser: true, unused: true, undef: true, strict: true */

(function (window, factory) {
  // universal module definition
  /*jshint strict: false*/ /*globals define, module, require */

  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(69)], __WEBPACK_AMD_DEFINE_RESULT__ = function (Unipointer) {
      return factory(window, Unipointer);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('unipointer'));
  } else {
    // browser global
    window.TapListener = factory(window, window.Unipointer);
  }
})(window, function factory(window, Unipointer) {

  'use strict';

  // --------------------------  TapListener -------------------------- //

  function TapListener(elem) {
    this.bindTap(elem);
  }

  // inherit Unipointer & EventEmitter
  var proto = TapListener.prototype = Object.create(Unipointer.prototype);

  /**
   * bind tap event to element
   * @param {Element} elem
   */
  proto.bindTap = function (elem) {
    if (!elem) {
      return;
    }
    this.unbindTap();
    this.tapElement = elem;
    this._bindStartEvent(elem, true);
  };

  proto.unbindTap = function () {
    if (!this.tapElement) {
      return;
    }
    this._bindStartEvent(this.tapElement, true);
    delete this.tapElement;
  };

  /**
   * pointer up
   * @param {Event} event
   * @param {Event or Touch} pointer
   */
  proto.pointerUp = function (event, pointer) {
    // ignore emulated mouse up clicks
    if (this.isIgnoringMouseUp && event.type == 'mouseup') {
      return;
    }

    var pointerPoint = Unipointer.getPointerPoint(pointer);
    var boundingRect = this.tapElement.getBoundingClientRect();
    var scrollX = window.pageXOffset;
    var scrollY = window.pageYOffset;
    // calculate if pointer is inside tapElement
    var isInside = pointerPoint.x >= boundingRect.left + scrollX && pointerPoint.x <= boundingRect.right + scrollX && pointerPoint.y >= boundingRect.top + scrollY && pointerPoint.y <= boundingRect.bottom + scrollY;
    // trigger callback if pointer is inside element
    if (isInside) {
      this.emitEvent('tap', [event, pointer]);
    }

    // set flag for emulated clicks 300ms after touchend
    if (event.type != 'mouseup') {
      this.isIgnoringMouseUp = true;
      // reset flag after 300ms
      var _this = this;
      setTimeout(function () {
        delete _this.isIgnoringMouseUp;
      }, 400);
    }
  };

  proto.destroy = function () {
    this.pointerDone();
    this.unbindTap();
  };

  // -----  ----- //

  return TapListener;
});

/***/ }),

/***/ 81:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Flickity v2.0.10
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * http://flickity.metafizzy.co
 * Copyright 2017 Metafizzy
 */

(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(17), __webpack_require__(102), __webpack_require__(104), __webpack_require__(105), __webpack_require__(106), __webpack_require__(107), __webpack_require__(108)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(require('./flickity'), require('./drag'), require('./prev-next-button'), require('./page-dots'), require('./player'), require('./add-remove-cell'), require('./lazyload'));
  }
})(window, function factory(Flickity) {
  /*jshint strict: false*/
  return Flickity;
});

/***/ }),

/***/ 98:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * matchesSelector v2.0.2
 * matchesSelector( element, '.selector' )
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */

(function (window, factory) {
  /*global define: false, module: false */
  'use strict';
  // universal module definition

  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.matchesSelector = factory();
  }
})(window, function factory() {
  'use strict';

  var matchesMethod = function () {
    var ElemProto = window.Element.prototype;
    // check for the standard method name first
    if (ElemProto.matches) {
      return 'matches';
    }
    // check un-prefixed
    if (ElemProto.matchesSelector) {
      return 'matchesSelector';
    }
    // check vendor prefixes
    var prefixes = ['webkit', 'moz', 'ms', 'o'];

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var method = prefix + 'MatchesSelector';
      if (ElemProto[method]) {
        return method;
      }
    }
  }();

  return function matchesSelector(elem, selector) {
    return elem[matchesMethod](selector);
  };
});

/***/ }),

/***/ 99:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Flickity.Cell
(function (window, factory) {
  // universal module definition
  /* jshint strict: false */
  if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(68)], __WEBPACK_AMD_DEFINE_RESULT__ = function (getSize) {
      return factory(window, getSize);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) {
    // CommonJS
    module.exports = factory(window, require('get-size'));
  } else {
    // browser global
    window.Flickity = window.Flickity || {};
    window.Flickity.Cell = factory(window, window.getSize);
  }
})(window, function factory(window, getSize) {

  'use strict';

  function Cell(elem, parent) {
    this.element = elem;
    this.parent = parent;

    this.create();
  }

  var proto = Cell.prototype;

  proto.create = function () {
    this.element.style.position = 'absolute';
    this.x = 0;
    this.shift = 0;
  };

  proto.destroy = function () {
    // reset style
    this.element.style.position = '';
    var side = this.parent.originSide;
    this.element.style[side] = '';
  };

  proto.getSize = function () {
    this.size = getSize(this.element);
  };

  proto.setPosition = function (x) {
    this.x = x;
    this.updateTarget();
    this.renderPosition(x);
  };

  // setDefaultTarget v1 method, backwards compatibility, remove in v3
  proto.updateTarget = proto.setDefaultTarget = function () {
    var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';
    this.target = this.x + this.size[marginProperty] + this.size.width * this.parent.cellAlign;
  };

  proto.renderPosition = function (x) {
    // render position of cell with in slider
    var side = this.parent.originSide;
    this.element.style[side] = this.parent.getPositionValue(x);
  };

  /**
   * @param {Integer} factor - 0, 1, or -1
  **/
  proto.wrapShift = function (shift) {
    this.shift = shift;
    this.renderPosition(this.x + this.parent.slideableWidth * shift);
  };

  proto.remove = function () {
    this.element.parentNode.removeChild(this.element);
  };

  return Cell;
});

/***/ })

},[295]);